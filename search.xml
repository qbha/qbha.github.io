<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>上传项目到github步骤</title>
      <link href="/post/34ef27.html"/>
      <url>/post/34ef27.html</url>
      
        <content type="html"><![CDATA[<p>前提：git安装完毕，github注册完毕，配置ssh-key完毕。</p><h3 id="首次提交"><a href="#首次提交" class="headerlink" title="首次提交"></a>首次提交</h3><h4 id="首先在github上创建一个新仓库"><a href="#首先在github上创建一个新仓库" class="headerlink" title="首先在github上创建一个新仓库"></a>首先在github上创建一个新仓库</h4><h4 id="建立本地仓库"><a href="#建立本地仓库" class="headerlink" title="建立本地仓库"></a>建立本地仓库</h4><p>首先进入项目目录中，执行下面指令进行初始化</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git init</span><br></pre></td></tr></table></figure><p>初始化后项目中会多一个隐藏文件夹.git</p><p>接着，将所有文件添加到仓库，执行下面指令</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git add .</span><br></pre></td></tr></table></figure><p>然后，把文件提交到仓库，双引号内是提交注释。执行下面指令</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git commit -m &quot;提交文件&quot;</span><br></pre></td></tr></table></figure><p>如此本次仓库建好了。</p><h4 id="关联github仓库"><a href="#关联github仓库" class="headerlink" title="关联github仓库"></a>关联github仓库</h4><p>复制仓库地址后，执行下面指令</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git remote add origin git@github.com:xxxxxx</span><br></pre></td></tr></table></figure><h4 id="上传本地代码"><a href="#上传本地代码" class="headerlink" title="上传本地代码"></a>上传本地代码</h4><p>执行下面代码</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git push -u origin main</span><br></pre></td></tr></table></figure><h3 id="拉取修改后提交"><a href="#拉取修改后提交" class="headerlink" title="拉取修改后提交"></a>拉取修改后提交</h3><h4 id="拉取代码，执行下面指令"><a href="#拉取代码，执行下面指令" class="headerlink" title="拉取代码，执行下面指令"></a>拉取代码，执行下面指令</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git pull</span><br></pre></td></tr></table></figure><h4 id="修改代码，查看状态"><a href="#修改代码，查看状态" class="headerlink" title="修改代码，查看状态"></a>修改代码，查看状态</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git status</span><br></pre></td></tr></table></figure><h4 id="提交代码"><a href="#提交代码" class="headerlink" title="提交代码"></a>提交代码</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git add .</span><br><span class="line">git commit -m &quot;第一次修改增加一行&quot;</span><br><span class="line">git status   查看状态</span><br><span class="line">git push    提交代码到github</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> github </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>论文查重原理</title>
      <link href="/post/ab39cba6.html"/>
      <url>/post/ab39cba6.html</url>
      
        <content type="html"><![CDATA[<p>论文查重系统的原理一般包括两个主要步骤：首先是文本预处理，将论文中的文本转换为计算机可读的方式；然后是计算相似度，利用某种算法进行相似度计算，达到检测目的。主要有以下几种原理：</p><h4 id="基于语义分析的原理"><a href="#基于语义分析的原理" class="headerlink" title="基于语义分析的原理"></a>基于语义分析的原理</h4><p>该原理利用词向量模型计算文本的相似度。将文章转换为数值化向量，利用向量之间的计算得出文章相似度。该原理的优点是可以处理较为复杂的语言结构，但缺点是需要大量的数据集作为支持。</p><h4 id="基于文本特征的原理"><a href="#基于文本特征的原理" class="headerlink" title="基于文本特征的原理"></a>基于文本特征的原理</h4><p>该原理利用文本的特征值作为计算相似度的依据。例如利用文本中的关键词、句型结构、标点符号等特征作为计算依据。由于该原理计算简单、实时性好，所以广泛应用于论文查重系统。</p><h4 id="基于机器学习的原理"><a href="#基于机器学习的原理" class="headerlink" title="基于机器学习的原理"></a>基于机器学习的原理</h4><p>该原理利用机器学习技术识别重复的论文。先将大量已有的训练数据导入模型中进行训练，再将新的论文数据导入模型进行检测。通过自我学习，不断优化模型，达到更准确的检测效果。</p><p>通过上述三种原理，现今的论文查重系统已能较为准确、自动地完成文本的比对和分析。尽管有些人会利用一些手段规避查重，但随着技术的不断升级，以及对抄袭、剽窃等行为的不断打击，相信论文查重技术会有越来越广泛的应用。</p>]]></content>
      
      
      <categories>
          
          <category> 生活 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 查重 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>软件需求工程复习</title>
      <link href="/post/e5a90af4.html"/>
      <url>/post/e5a90af4.html</url>
      
        <content type="html"><![CDATA[<h4 id="软件需求概述"><a href="#软件需求概述" class="headerlink" title="软件需求概述"></a><strong>软件需求概述</strong></h4><p>软件需求：是指软件系统需要满足的功能、性能、约束和质量等方面的要求和期望。它是软件开发过程中的第一步，是软件系统设计和开发的基础。软件需求描述了软件系统需要实现的功能、性能、界面、数据、安全、可靠性、可维护性等方面的要求和期望，以及软件系统与外部环境之间的交互和接口等方面的要求和期望。软件需求是软件开发过程中最重要的一步，它直接决定了软件系统的功能、性能、可靠性和用户体验等方面，对于软件项目的成功与否起着至关重要的作用。因此，需要采用多种需求分析技术、制定详细的需求规格说明书、及时处理需求变更、进行需求验证和确认等措施，以确保需求的准确性和完整性，为后续的开发和测试工作奠定坚实的基础。需求工程：需求工程尝试为一个产品的用户和开发人员建立一个共同的需求基础。所以需求工程在整个产品开发过程中非常关键。开发人员与需求人员不同：做需求的人和做开发的人应该是两种具有不同思维的人，做需求的人员应具有集成的思维，把问题集成起来考虑；而做开发的人通常具有分解的思维，需要把要解决的问题分解为对象，分解为模块，然后逐一解决。用户需求特点：零散：用户可能从不同角度，提出不同层面，不同力度的需求，需求的表达形式也多种多样。存在矛盾：多个用户处于组织的不同岗位、不同层面，他们提出的需求可能存在片面性，甚至不同用户的需求可能还会相互矛盾。业务需求输出的主要内容： 高层业务需求（业务目标），涉众需求，业务流程，业务规则，词汇表。用户需求的主要输出：特性，功能需求，非功能性需求。系统需求的主要输出：界面说明，交互接口。需求层次的划分体现了需求工作的不同阶段及其产物。业务需求是需求定义的产物，用户需求是需求捕获的产物，系统需求是需求分析与建模的产物。</p><h4 id="需求方法和需求分析师"><a href="#需求方法和需求分析师" class="headerlink" title="需求方法和需求分析师"></a>需求方法和需求分析师</h4><p>需求工程是指应用已证实有效的技术、方法进行需求分析，确定客户需求，帮助分析人员理解问题并定义目标系统的所有外部特征的一门学科。需求工程通过合适的工具和记号系统地描述待开发系统及其行为特征和相关约束，形成需求文档，并对用户不断变化的需求演进给予支持。需求管理的主要工作：评估正式提交的变更请求，确定变更对现有需求集的影响；重构变更后的用例模型；设置适当的需求属性和可追踪性；正式验证需求工作流程的输出结果是否满足客户对系统的需求。软件生命周期：瀑布模型核心思想：按工序将问题化简，逻辑设计与物理实现分开。将软件生命周期划分为：制定计划、需求分析、软件设计、代码编写、软件测试、软件维护。自上而下、相互衔接的固定次序。只有当一个阶段的文档编制好并获得SQA小组的确认后才可以进入下一个阶段。通过强制提供规约文档来确保各个阶段很好的完成任务。瀑布模型优点：是一个阶段性的软件开发模型，通过使用里程碑，使每个阶段具有可识别的起点和终点。在编写代码之前充分强调需求和设计，避免了时间的浪费，由于在需求和设计阶段捕获并修正可能存在的漏洞要比在后序阶段容易得多，因此，瀑布模型有利于提高软件产品的质量。在需求和设计阶段生成了规范的文档资料，当团队成员分散在不同的工作地点时，瀑布模型有助于进行信息的有效传递。瀑布模型缺点：整个模型几乎都是以文档驱动的，这对于非专业的用户来说是难以阅读和理解。需求的获取是一个不断深入的过程，对于一个项目而言，无论花多少时间和精力与用户沟通，理解用户之所想，也不可能一次获得所有需求。然而，在瀑布模型中，软件开发的各项活动要求严格按照线性方式，需求分析阶段的结果将作为下一阶段的输入，早期的错误可能要等到开发后期才能发现，进而带来严重的后果。RUP模型：RUP（Rational Unified Process）是Rational结合软件工程理论推出的软件过程模型（2002），商品化最成功的软件过程模型。RUP是可配置的： RUP根据实际做出一定的取舍，合理输出最有价值的文档，执行最有价值的核心工作流。RUP是风险驱动的：RUP各个阶段是为了化解不同的风险，持续的化解风险是RUP的灵魂RUP是以架构为中心的：架构风险是一个重大风险，RUP提倡有稳定的架构，在细化阶段必须产生稳定的架构，达到项目的架构里程碑。RUP是用例驱动的：项目实现的过程就是用例一个个实现的过程，各个阶段实现不同的用例，随着用例的实现，可执行的产品逐渐生成。RUP核心思想：确保满足用户需求：采用进化式需求，迭代开发确保满足用户需求。RUP的最终目的是产生更好的可执行的软件，而不是创建文档。尽早地适应变化：早期只分析和实现优先级最高的用例，细化阶段迭代产生稳定的架构以适应变化。始终重视质量：每个阶段的结束都有测试，采用尽早地持续地测试。在迭代过程中不再采用传统的需求规格说明、设计说明等预先定义好的需求和设计工件。取而代之的是采用“基于发现”的方法。在迭代模型中，采用象愿景文档、用例模型等轻量级的文档，只是初步地定义要建立的软件，根据这些初步地理解，在前面的几个迭代中会很快地发现“真实的用户需求”，从根本上降低了项目的风险。RUP结构：RUP有四个主要的建模元素：角色、工件、活动和工作流。RUP结构中描述了谁（角色）在做什么（工件），怎么做（活动），什么时候做（工作流）。RUP模型中软件生命周期四个阶段：先启（初始）阶段(Inception)精化阶段(Elaboration)构造阶段(Construction)移交阶段(Transition) 先启阶段结束时：生命周期目标里程碑 — 用于评价项目基本的生存能力。精化阶段结束时：生命周期结构里程碑 — 为系统的结构建立管理基准并使项目小组能够在构造阶段进行衡量。此刻，要检验详细的系统目标、范围、结构的选择、主要风险的解决方案。构造阶段结束时：初始功能里程碑。该里程碑决定了产品是否能够在测试环境中进行部署,要确定软件、环境、用户是否能够开始系统的运作。这时的产品版本常被称为“beta”版。移交阶段的终点：产品发布里程碑。此时，要确定目标是否已经实现，是否可以开始另一个开发周期。在某些情况下该里程碑可能与下一项目周期先启阶段的开始重合。RUP9个核心工作流：6个核心过程工作流(Core Process Workflows)工作流：商业建模工作流、需求工作流、分析和设计工作流、实现工作流、测试工作流、部署工作流、3个核心支持工作流(Core Supporting Workflows)：配置和变更管理工作流、项目管理工作流、环境工作流。RUP的需求工作流目标是描述系统应该做什么，并使开发团队与用户就这一描述达成共识。为了达到此目标，RUP描述了如何对系统的功能和约束条件进行提取、组织并将其文档化。RUP迭代开发模式：RUP中的每个阶段可进一步分解为迭代。每个迭代均是一个完整的开发循环，产生产品的一个可执行版本，即最终产品的一个子集。从一个迭代过程到另一个迭代过程，不断增量式地演进，直至实现最终系统。敏捷软件开发：更强调开发团队与业务专家之间的密切协作、面对面的沟通（敏捷开发认为面对面的沟通比书面的文档更有效）、频繁交付新的软件版本、紧凑而自我组织型的团队、能够很好地适应需求变化的代码编写和团队组织方法，更注重软件开发中人的作用，更注重应对快速变化的需求的一种软件开发能力。敏捷方法特点：更关注协作。更关注质量。更关注可工作的产品。更关注全才化的专才。是基于实践的，而不是基于理论。IBM对敏捷的定义为：通过持续的利益相关人反馈，使用用例（或用户故事）和一系列短小且是固定时间的迭代去发布高质量的，高可用性的代码。敏捷项目与传统项目对比：在敏捷项目中，需求在整个生命周期中是不断变化的。明确高层次需求，并进行优先级划分。时间是影响紧急业务需求交付的关键约束资源固定，并被有效管理，在指定成本和时间内交付高质量产品。在敏捷项目中，需求通常以任务列表的形式进行描述，其优先级是可动态调整的；而在传统项目中，需求在一开始是被完整定义的和静态的。需求被充分定义和固化，时间就是项目生命周期，变化的资源以减少时间。XP编程：XP是由KentBeck在1996年提出的、适合于中小型系统的、测试驱动的敏捷开发方法。“Extreme”（极限）是指与传统的软件开发方式相对比，XP强调把它的每个方法和思想做到极限，而XP所不提倡的，如开发前期的整体设计等则将一概忽略。XP的关键：一个5-10人的开发团队与客户代表一起在现场工作。开发在不断地迭代，交付的功能不断递增。需求以用户故事的方式进行说明。程序员结对编程，遵循严格的编码标准，并进行单元测试，客户参与验收测试。在整个项目过程中，需求、架构和设计逐渐融合。必须遵循严格的编码限制以保证其代码具有极高的质量。XP 强调四种价值：交流，简易，回馈，勇气。XP特别强调客户满意度，是以构建满足客户需要的软件为目标而产生的方法论。XP强调团队合作，充分发挥人的优势，弱化人的缺点。XP属于轻量级的方法，认为文档、架构不如编程来的直接。Scrum：三个角色（ProductOwner,ScrumMaster，TeamMember）四个会议（Sprint计划会议，每日站立会议，Sprint评审会议，Sprint回顾会议）三个工件(ProductBacklog，SprintBacklog，BurndownChart)Scrum过程：产品负责人根据客户的需求编写产品订单(Product Backlog)，这是一张包含大量用户故事的清单，各项需求已按优先级进行排序。然后，产品负责人与团队一起评估并制定产品开发计划，计算出完成该项目需要多少个Sprint（迭代）。由于敏捷开发注重对客户要求的快速反应，因此，产品订单中的内容及其优先级不是一成不变的，而是会随着项目的进行而不断变化的。在每个Sprint开始时，从Product Backlog中拿出优先级高的用户故事，召开Sprint计划会议，评估各项功能的相对工作量，并确定该Sprint的愿景和目标，生成Sprint Backlog。在Sprint的开发过程中，召开每日站立会议，Scrum Master通过十五分钟的每日站立会议检查团队成员的工作与进度，了解开发过程中出现的问题并及时协调。迭代结束时，所有人员参加迭代评审会议（Sprint Review Meeting），向项目干系人展示可运行的增量版本，并检查是否达到了Sprint目标。评审会议之后的迭代回顾会议（Sprint Retrospective Meeting）总结实践经验以提高团队生产力。Scrum的需求：Scrum团队Product Backlog是Scrum的核心，是一切活动的起源。Product Backlog是一个由需求（用户故事或特性等）组成的列表，其中的条目按重要性的级别进行排序。编写Product Backlog就是对需求进行建模。根据敏捷建模“主张简单”的原则，在描述Backlog中的条目时，通常借鉴XP方法中用户故事的描述方式。敏捷建模认为“内容比形式更重要”，在表示Backlog时，可以使用Excel创建Backlog，也可以使用即时贴，将Backlog展示在白板上，使每个人都能直接看到需求模型。Scrum负责需求建模的主要是Product Owner和客户。Product Owner对客户做深入的访谈，分析捕获的需求，再花1-2天时间整理出几十个用户故事。客户看到每个迭代交付的可运行的软件后，常常会有新的需求。经过认真的分析，找出需要立即考虑的或不用急迫实现的。Product Owner在每个迭代内要和客户一起分析好足够下一个迭代开发的需求。在迭代计划会议上，Product Owner向所有的开发人员解释这个迭代要完成的用户故事，开发人员可自由提问，直到他们获得足够信息。开发人员完成一个用户故事后，Product Owner还要来代替客户做验收测试，并检查是否有开发人员还没有想到的异常情况。如果存在问题需要退回给开发人员继续完善。这在一定程度上保证了系统完成的需求不偏离客户的要求。需求分析师：（也叫需求工程师、系统分析师/员、业务分析师），是客户、用户、市场/营销、产品管理和开发之间的联系纽带。他负责获取和编写客户需求并派生出用户需求和软件需求。软件需求分析其根本性问题是理解用户功能需求，由此软件需求分析实际上是与客户间交流过程完成的目标。需求分析师在整个项目管理过程中，扮演一个非常重要的角色，是用户和项目团队的接口。需求分析师工作职责：主要工作职责为：定义业务需求。确定项目涉众和用户类别。获取需求。分析需求。为需求建模。编写需求。主持对需求的确认。引导对需求的优先级划分。管理需求。需求分析师的能力要求：一位好的需求分析师应具备多方面的综合素质，具有坚实的编程功底和丰富的编程经验，合理的知识结构，较强的口头、书面表达能力，思维敏捷，思路缜密，逻辑分析能力强，以有效的获取需求，管理需求团队。具体应具备以下工作技巧：倾听、交谈和提问的技巧。分析和协调能力。观察能力。写作能力。组织能力。建模能力。人际交往和创造能力。</p><h4 id="涉众需求"><a href="#涉众需求" class="headerlink" title="涉众需求"></a>涉众需求</h4><p>涉众需求：涉众需求是指在某个项目或产品开发过程中，与该项目或产品相关的各方利益相关者（即“涉众”）对该项目或产品所提出的需求。这些涉众可以包括客户、用户、员工、投资者、政府机构、社区组织等等。涉众需求的重要性在于，一个项目或产品的成功往往取决于是否满足了各方利益相关者的需求。如果某些利益相关者的需求被忽略或没有得到妥善处理，可能会导致项目或产品的失败，甚至可能对组织或社会造成不良影响。需求捕获的方法概览：需求捕获是软件项目的基础，对后续的分析、设计及开发有重大影响。如果需求捕获做的好，需求变更将会减少且更容易实现。需求捕获过程的质量也将决定客户对软件需求的正确性、完整性的认可。需求捕获是两个团体相互沟通，识别需要的过程。需求捕获的成功既涉及技术问题，也涉及社会交往问题。需求捕获可进一步分为：确定需求源（识别需求的提出人或称之为风险承担者）。网罗信息（收集各方人员对产品的要求，得到“期望列表”）。整和（反复分析“期望列表”直到前后一致，得到提炼后的文档化的“期望列表”）。头脑风暴：一群人围绕一个特定的兴趣领域产生新观点的情境。在需求分析人员对行业业务缺乏认识或者认识较少的情况下，充分发挥团队成员想象力，利用集体智慧构造出一个业务问题模型和解决方案模型。如果有对业务熟悉的相关人员参加效果会更好，讨论的效率会更高。在项目初期，在项目范围固定下来之前，所有项目均应该至少安排一次头脑风暴。头脑风暴环节：1确定议题：需要在会前确定一个目标，使与会者明确本次会议需要解决的问题。2会前准备：为了使头脑风暴会议取得理想效果，可在会前做适当的准备工作。如分发“热身”资料，使与会者了解与议题相关的背景材料和外界动态。3确定人选：一般以8人～12人为宜，可略有增减（小组全体成员）。与会者人数太少不利于信息交流，激发思维。 4明确分工：会议要有一名主持人，1～2名记录员。在头脑风暴会议开始时，主持人重申讨论的议题、纪律，在会议过程中启发引导，掌握进程， 5规定纪律：主持人开始时规定几条纪律，例如，要集中注意力，积极投入，不消极旁观；不要私下议论，以免影响他人的思考；发言要针对目标，开门见山，不要客套，也不必做过多的解释。6掌握时间：，会议时间最好安排在30～45分钟之间。徜若需要更长时间，则应把议题分解成几个小问题，分别进行专题讨论。头脑风暴过程：第一部分的目标是产生尽量多的想法。自由畅谈。禁止批评和责备。追求数量。变更或合成想法。第二部分的目标则是把想法列表减小到一个可操作的规模。门限投票法。竞选演讲投票法。选择用户角色集合：通过头脑风暴，获取初始的用户角色集合。整理初始的用户角色集合。整合用户角色。提炼用户角色。（不同）用户角色建模：①通过头脑风暴，获取初始的用户角色集合。每个人想到一个用户角色就在记录卡上写下其名称，每个人只是尽量多地在卡片上写出自己想到的用户角色。②整理初始的用户角色集合。把有重叠的角色的卡片也重叠在一起，以表明用户角色之间的关系。这样用户角色就会分成了几个组。③整合角色通常从完全重叠的记录卡入手。首先，记录卡的作者描述他们命名的用户角色的含义，经简短的小组讨论，判断出这些用户角色是否等同，若等同，则合并成一个④提炼角色在整合角色后，就可以对每个角色定义属性来建立角色模型了。角色属性是关于同一类用户的有用信息。下面是一些通用的角色属性。使用软件的频率。使用计算机和软件的总体水平。相关领域的知识水平。用户使用软件的总体目标。例如，有的用户注重便捷性，有些用户则更多关注丰富的用户体验。虚拟人物：虚构人物是假想的用户角色代表。对于虚构人物不仅是在用户角色上加个名字，更重要的是需要对虚构人物的特点进行充分描述，使其活灵活现，让团队中每个人都感觉知道这个人物。极端人物：定义极端人物可能会产生新的用户故事，但是，很难事先确定是否应该把这些用户故事包含在产品中。极端人物有助于搜集原本可能被遗漏的用户故事。访谈：是最常见、最基本的需求捕获技术，也是最直接、最全面和最有效的获取需求的渠道，其中蕴含着大量的技巧，访谈者是否善于运用这些技巧，将直接影响到访谈的效果。访谈技巧之一要求准备一个问题列表，目的是了解真实的问题以及潜在的解决方案。访谈的五个阶段：1、访谈准备。在进行访谈前，需求分析人员应该很好的理解被访谈客户的情况，根据项目类型可能包括组织结构、行业定位、项目范围及项目目标。2、访谈计划在访谈之前应围绕目标对访谈的时间、地点、人员、内容进行计划。尽量将要访谈内容提前发给被访谈者，使其能够提前做好准备，提高访谈效率。需求的不同阶段访谈对象是不同的，且对于不同的访谈对象，其话题中心、访谈目标也是不同的。因此，需要准备不同的问题清单。3、访谈开始和结束：开始访谈时：先简单介绍自己。陈述访谈的目的。谈谈参与访谈者关心的事情。说明有一些简短的访谈纪要，在整理后请与会者审阅。结束会谈时：简短总结讨论过的问题要点，并阐明你的理解。这使被访谈者了解到你认真倾听了他们的谈话，同时也提供了一个澄清误解的机会。4、引导访谈：开场白（陈述预先的理解，聚焦访谈的话题）计划问题（寻求问题的答案，主题工作）即兴问题（扩大需求信息量，不宜过度扩展）总结（总结访谈内容，访谈者向被访谈者陈述）封闭式问题（判断题）半封闭式问题（选择题）开放式问题（简答题）访谈要抓住细节：“4W1H”What：业务的内容是什么Who：哪些人员会参与业务过程When：什么时候发生该业务过程Why：为什么会出现这个问题How:怎么做才能完成业务目标。5、后续的访谈整理工作访谈的优缺点优点：形式灵活、直接有效、交流深入。缺点：语言交流占用时间长，用户代表了解信息不全面，容易造成信息的片面性。需求捕获研讨会：让开发团队与项目涉众见面；从项目涉众那里收集全面的“期望列表”；对所收集到的需求区分优先顺序。研讨会过程：（1）准备研讨会：充分的准备是获得成功的关键。（2）日程安排：需求捕获研讨会的议程应以项目需求和研讨会上所要讨论的开发内容为基础，会因具体的项目而异。（3）举行需求捕获研讨会。业务规则：描述和规定了组织机构的政策方针，用于表示一个特定组织的某个细节规定。若需求描述为特定用户在特定条件下才能执行某一行为时，该需求可能描述的是一条业务规则。业务规则不是功能性需求，需要加以区别。约束：要么是设计中必须遵循的限制，要么经过约束分析、转化为质量属性需求或者功能需求。需求分析员应该核实其正确性，准确表述出真正的约束，并记录把该约束作为需求的原因，让设计人员根据这些信息进行设计。数据字典：是一种用户可以访问的记录数据库和应用程序源数据的目录。当客户描述某一数据，限定了其格式、类型、允许值及默认值时，或者描述某一复杂业务数据内容由哪些数据项构成时，就是在进行数据定义。需求分析员应该把所有的数据定义到一起，形成数据字典。在产品的整个开发和维护过程中，数据字典一直是一个主要的参考。</p><h4 id="用例方法"><a href="#用例方法" class="headerlink" title="用例方法"></a>用例方法</h4><p>用例：是一种描述系统功能性需求的方法。使用用例来描述系统需求的过程叫做用例建模。用例模型主要由以下模型元素构成:用例和参与者。用例是用来描述系统的功能性需求，而不是非功能性需求。参与者是指系统以外的，需要使用系统或与系统交互的人、设备或其他系统，他们代表的是系统的使用者或使用环境。参与者分为三大类：人，也就是通常所说的用户。对于这一类参与者，应当按照业务命名。与该系统进行交互的其它系统。一些可以运行的进程。通讯关联：通讯关联表示的是参与者和用例之间的关系，表示参与者使用了系统中的用例。在UML中用连线表示通讯关联,箭头表示在这一关系中哪一方是对话的主动发起者，箭头所指方是对话的被动接受者。用例的场景：那么所有这些可能发生的各种情况被称之为用例的场景。场景也被称作是用例的实例。在用例的各种场景中，最常见的场景是用基本流来描述的，其他的场景则是用备选流来描述。基本流和备选流：对于ATM系统中的”提款”用例，1.用户插入信用卡 2.输入密码 3.输入提款金额 4.提取现金5.退出系统取回信用卡。我们可以得到如下一些备选流：·提款-备选事件流。备选流一：用户可以在基本流中的任何一步选择退出，转至基本流步骤5。备选流二：在基本流步骤1中，用户插入无效信用卡，系统显示错误并退出信用卡，用例结束。备选流三：在基本流步骤２中，用户输入错误密码，系统显示错误并提示用户重新输入密码，重新回到基本流步骤2；三次输入密码错误后，信用卡被系统没收，用例结束。用例方法的优点：用例方法完全是站在用户的角度上来描述系统的功能的。把被定义系统看作是一个黑箱，描述了系统为外部的参与者提供了什么样的服务，而并不关心系统内部。每一个用例描述的是一个完整的系统服务，易于被用户所理解，是开发人员和用户之间针对系统需求进行沟通的一个有效手段。建立用例模型：使用用例方法来描述系统的功能需求的过程就是用例建模。用例模型主要包括以下两部分内容：用例图：在UML中，一个用例模型由若干个用例图描述。用例图是显示一组用例、参与者以及他们之间关系的图。用例规约：通过用例规约文档描述每一个。用例的细节内容 。用例建模的过程，首先找出系统的参与者，然后根据参与者确定与每个参与者相关的用例，最后细化每一个用例的用例规约。描述用例规约：由参与者和用例构成的用例图并不是用例模型的全部，用例图在总体上描述了系统所能提供的各种服务，使人对系统的功能有一个总体的认识，用例规约用来描述每一个用例的详细信息。也就是说用例模型是由用例图和用例规约组成的。RUP中用例规约模板：简要说明：简要介绍该用例的作用和目的。事件流：包括基本流和备选流，事件流应该表示出所有的场景。 用例场景 ：包括成功场景和失败场景，场景主要是由基本流和备选流组合而成的。 特殊需求：描述与该用例相关的非功能性需求（包括性能、可靠性、可用性和可扩展性等）和设计约束（所使用的操作系统、开发工具等）。 前置条件：执行用例之前系统必须所处的状态。 后置条件： 用例执行完毕后系统可能处于的一组状态。基本流描述的是用例最正常的一种场景，系统执行一系列活动步骤来响应参与者提出的服务请求。备选流负责描述用例执行过程中的异常情况，备选流和基本流的组合应该能够覆盖该用例所有可能发生的场景。在描述备选流时，应该包括以下几个要素：起点：该备选流从事件流的哪一步开始；条件：在什么条件下会触发该备选流；动作：系统在该备选流下会采取哪些动作；恢复：该备选流结束之后，该用例应如何继续执行。用例场景是用例的实例，也就是说用例在实际执行的时候会有很多的不同情况发生.检查用例模型：功能需求的完备性:现有的用例模型是否完整地描述了系统功能，这也是判断用例建模工作是否结束的标志。 模型是否易于理解:用例模型最大的优点是易于被不同的涉众所理解，因而用例建模最主要的指导原则就是它的可理解性。用例的粒度、个数以及模型元素之间的关系复杂程度都应该遵循该指导原则。是否存在不一致性: 用例模型由多个系统分析员协同完成，模型本身由多个工件所组成的，所以同工件之前是否存在前后矛盾或冲突的地方，避免模型内部产生不一致性，影响到需求定义的准确性。 避免二义性语义: 好的需求定义应该是无二义性的，即不同的人对于同一需求的理解应该是一致的。在用例规约的描述中，应该避免定义模糊的需求，即无二义性。用例方法的局限性用例在捕获系统功能需求上表现很优秀，但其只涉及功能性需求，并不适合方便的捕获非功能性需求，还需要借助于其它的方法。用例模版不能自动保证清晰，清晰要依靠书写者的技巧。用例分析结构的好坏与分析人员的个人经验和领域知识有很大的关系。用例与敏捷项目：在大规模的精益和敏捷项目中，用例作为需求建模的工具很有价值。在精益和敏捷（特别是XP和Scrum）中，用例的使用范围并不广，人们更多地使用用户故事收集需求，但是在构建大规模复杂系统时，用例可以发挥其强大作用，发现用户、系统以及子系统之间的互动关系。</p><h4 id="用户故事"><a href="#用户故事" class="headerlink" title="用户故事"></a>用户故事</h4><p>定义：用户故事就是系统要为用户所做事情的简短的陈述。是用开发者和用户都能理解的方式定义系统行为的工具。重点集中在用户定义的价值上，而不再把重点放在传统的功能性的结构分解上。提供了一种轻量级的、有效的管理需求的方法。XP项目中的用户故事：用户故事起源于XP。故事是XP项目中的功能单元；团队通过交付实现的故事展示项目的进展；一个故事对客户应该是可理解的，对开发者是可测试的，对客户是有价值的，并且要足够小，使得一个编程人员在一个迭代中能完成多个（如6~10个）。谁写用户故事：在XP项目中，通常由客户书写用户故事，这样客户需要直接参与整个项目的开发过程。在Scrum项目中，产品经理（Product Owner）常常书写用户故事。基本概念：用户故事利用索引卡或在线工具记录对一个功能的简短陈述。用户故事的简短描述中不会出现系统行为的细节，要想实现用户需要的功能，还应该有更详细的细节和验收标准。用户故事的组成：用户故事的组成 -3C卡片包含了用户故事的简短文字描述、沟通获得的细节、测试时的细节。卡片（Card），用2~3句话简短描述故事的目的，用来做计划（工作量估算）或者备忘。对话（Conversation），记录用户故事背后的细节，来源于和客户或产品负责人的沟通交流。确认（Confirmation），代表验收测试，即客户和产品经理如何确认故事已经根据用户的要求实现。确认表示的是判断用户故事是否完成所满足的条件，是更详细的需求。通过客户或客户代理验收测试，确认用户故事被正确地完成。用户故事标准形式：作为一个&lt;角色&gt;，我能做&lt;活动&gt;以便于&lt;商业价值&gt;。&lt;角色&gt;代表谁正在执行指定的活动或谁会收到活动执行的结果。&lt;活动&gt;代表系统执行的动作。&lt;商业价值&gt;代表通过执行活动获得的益处。用户故事的细化：当用户故事能涵盖细节时，就不必再进行分割了。用户故事验收条件：验收条件应该简单、扼要，可以随时增加或删除，验收的目的就是验证用户的期望是否已经满足，若已经达到了用户的期望，则开发人员就该结束该故事。验收条件不是单元测试而是系统应该满足的条件。单元测试需要更深入地测试功能流、异常流、边界条件及与故事相关的所有功能。用户故事的验收测试：在敏捷开发中把功能确认称为“用户故事验收测试”，即验证用户故事确已正确实现。为了与用户故事本身相区别，把“用户故事验收测试”作为一种工件。验收测试是验证系统是否实现了用户故事预期目标的功能性测试。为了避免产生大量的手工测试，故事的测试尽可能采用自动测试。用户故事的单元测试：开发人员进行单元测试的目的是测试子模块代码的执行逻辑。在测试驱动的开发模型中，在编码之前就要写好测试用例。总之，必须经过编写测试用例、测试通过，然后建立自动测试框架，一个故事才算完成。用户故事和用例的区别：用户故事：作用：1.作为进度跟踪的依据；2.作为与人交谈的备忘录。不是精确的需求，不需要非常清楚的描述，把详细分析推迟到实现前夕进行。用户故事是可见的商业价值，而不是功能描述。用例：需要详细的描述各操作步骤以及所有异常路径，起到文档的作用。功能描述，不同用例的粒度和工作量可能相差很大。INVEST模型：独立性（Independent）独立性意味着一个故事可以独立地开发、测试甚至交付，因此，也能单独对其进行评价。可协商性（Negotiable）用户故事是可以讨论的。它们不是签署好的合同或者软件必须实现的需求。故事卡是功能的简短描述，细节将在客户和开发团队的讨论中产生。由于没有过度的限制和过多的需求细节，增强了团队和企业在功能和交付日期之间进行权衡的能力。有价值的（Valuable）每个用户故事必须提供一些价值给用户、客户或干系人。价值是INVEST模型中最重要的特性。未完成产品订单是根据价值进行优先级排序，产品的成功与失败也是基于团队交付的价值而定。可估计的(Estimable)团队应该能对故事的复杂性和需要的工作量进行一个大概的估计。为了每个迭代都能交付价值，对一个故事的估计至少应能确定它在一个迭代中是否可以完成，更加准确的估计将提高团队的可预测性。短小（small）一个用户故事能在一个迭代中完成，否则，团队无法提供任何价值。短小的故事能降低故事的复杂度,增强生产能力，使团队更敏捷高效。写软件功能的规则：规则1：做一件事情。规则2：短小。规则3：让它们更小。可测试性（Testable）每个故事都是可测试的。成功通过测试可以证明开发人员正确的实现了故事。为了保证不能完成的用户故事就不能进入迭代，许多敏捷团队采用“测试先行”的方法，即在写代码之前先写测试用例。封闭的用户故事：是指那种随着一个有意义的目标的实现而结束的用户故事，能让用户使用后感觉完成了某个任务的用户故事。团队应基于用户故事实现的时间跨度，编写故事。根据实现时间确定用户故事的规模。故事点估算：一个团队可能定义一个理想日（没有会议，没有电话，没有电子邮件，也就是没有任何打扰的一天）的工作为一个故事点。另一个团队可能定义一个理想周的工作为一个故事点。相较于用连续时间估算，理想时间更简单，因为用持续时间估算时人们不得不考虑周围可能的各种影响，估算用户故事由整个团队集体完成有两个原因：还不知道团队中的谁会负责实现该用户故事，所以要把故事分配给整个团队而不是某人。团队进行估算可能比某人估算更有用。Wideband Delphi估算方法：把所有参与估算的开发人员和客户聚在一起。客户随机抽取一个用户故事，读给所有开发人员听。开发人员根据需要尽可能多提问，客户尽其所能解答。每个开发人员在空白笔记卡上写下一个估算值，每人展示其估算值。若估算值不同，估算值高的和低的再解释一下估算依据。估算了几个故事后，应该对估算进行三角测量。三角测量就是根据这个故事和其它故事的关系来估算故事。三角测量做法：在墙上画一些竖线，每一列标明故事点数，然后把故事卡贴到相应的列中，对每个新故事进行估算后，将其放到相应的列中，可以很快地检测出刚估算的故事和这列的其它故事比较是否基本相同。故事点的应用：在一轮迭代结束时，团队会计算已完成的故事点数（冲刺回顾会议、评审会议）。因为下一轮迭代也应该完成同样的故事点数。“速率”表示团队在一轮迭代中完成（或期望完成）的故事点数——团队的开发能力评估。发布计划：发布周期：软件项目通常以2到6个月为一个新的发布周期，某些网站项目可能发布周期更短。什么时间发布？由于开发速率是预测的，团队做发布计划时希望可以和客户商定一个日期范围，而不是一个具体的日期。团队可以做出这样的发布计划：在2或3轮迭代后，系统会有最基本的功能，5到6轮迭代后，系统会有1.0版本的所有功能。故事的优先级是怎样的？为了制定一个发布计划，客户必须排列故事的优先级。莫斯科（MoSCoW）规则：必须有（Must have）:系统的基本功能。应该有（Should have）:很重要，但近期有替代方法的功能，将来一定要有的。可以有（Could have）:如果时间不允许，发布中可以不考虑的功能。这次不会有（Won’t have this time）:客户希望有，需要在后续发布中实现的功能。选择迭代长度：开发人员和客户要一起选择适合的迭代长度：一般为1至4周。短迭代的好处是允许项目较频繁地进行调整，项目进展更透明；但是，每轮迭代会有一些额外的开销。与短迭代相比，长迭代中出错的几率更大。在项目开发过程中，尽可能地保持固定的迭代长度，有利于团队的开发速度。获得初始速率的方法通常有以下三种。使用历史值（适合于团队人员没有变化且刚做过类似的项目 ——这种情况非常少见）。执行第一轮迭代，后面使用第一轮迭代的速率（适合开发成本较低的项目）。猜测 （适合开发成本较高）。将用户故事分解为任务：1将故事分解为更小的任务会更加符合项目的需要。有助于发现那些可能会被遗忘的任务。故事分解任务准则：若故事的某个任务难于估算（比如数据支持的格式列表需要上级领导的批准），就把该任务从其它任务中分离出来。2通过分解可以让多个开发人员合作完成同一个故事。例如，在上面故事的分解中，实现基本、高级搜索界面就是分开的任务。若团队正在使用用户界面设计师或专门的界面设计小组，“实现基本的搜索界面”也可以分解为两个任务：“设计基本搜索界面的布局”和“实现基本搜索界面的代码”。3若希望让客户了解故事某一部分的完成情况，可以把那部分分离出来作为一个任务。若承担的任务难以完成，可以有以下选择。请求团队中的其他成员接手一部分任务。留着所有任务，寄希望于一切顺利。与客户讨论，放弃一些任务。</p><h4 id="非功能性需求与制作需求原型"><a href="#非功能性需求与制作需求原型" class="headerlink" title="非功能性需求与制作需求原型"></a>非功能性需求与制作需求原型</h4><p>非功能性需求类型：易用性需求。观感需求。执行需求。操作及环境需求。可维护性及支持需求。安全性需求。文化政策及法律性需求。敏捷需求模型中的非功能需求在敏捷项目中，由于整个团队的焦点集中在未完成订单上，不会专门为非功能性需求进行建模，通常把非功能性需求作为未完成订单的限制。易用性：易用性是指软件被理解、学习、使用和吸引用户的能力。易用性的三原则：易见：就是各种功能操作不要藏得太深，用户很容易找到他们期望进行的各种操作。易学：是指通过在线帮助，导航，向导等方式保证软件是可自学的。易操作：熟练使用软件后应该可以更快更方便进行各项操作。还涉及到美工和UI界面，人机工程，交互式设计，心理学，用户行为模式等多方面的知识。可靠性：可靠性是指与在规定的一段时间和条件下软件维持其性能水平的一组属性：可用性：在要求的外部资源得到保证的前提下，产品在规定的条件下、规定的时刻或时间区间内处于可执行规定功能状态的能力。平均无故障时间:是指平均能够运行多长时间才发生一次故障。平均修复时间：描述产品由故障状态转为工作状态时修复时间的平均值。缺陷：缺陷会降低系统的可用性和用户的满意度。安全性：例如，要求安全级别较高的密码容错性：当错误发生时，软件会给出适当的提示或处理。可靠性与维护性：当系统出现故障和用户出现错误操作后是否支持恢复。当用户遇到错误的时候是否可以立即定位问题。当网络不稳定或异常发生的情况下，系统是否具有相应的容错措施。当业务场景和逻辑发生变化的时候系统是否支持。性能：性能需求:软件需要以特定的精度、速度或容量执行某些任务。性能需求具体方面：响应时间：通常用特定事务的平均和最坏情况表示。吞吐量：如在单位时间内完成的任务数，数据的传输速率等。容量：系统能同时容纳的客户数、事务数或数据量等。可扩展性：系统可扩展为同时容纳更多客户、事务的能力。资源利用率：说明该系统使用CPU、内存、磁盘存储、带宽等资源的情况。执行结果的精度:例如，在财务系统中，产生的结果是精确到分、角还是元等。允许值的范围。可维护性：软件的可维护性是指维护人员为纠正软件的错误、缺陷或满足用户新的需求而理解、修改和改进软件的难易度。可维护性的评价维度：可读性：指编码风格，如格式、命名、对齐、注释等。可理解性：强调代码编写应遵循的约定俗成的模式，不要将代码写的太个性化，使人难以理解；可追溯性：代码各部分之间依赖越少，隔离性越强，则追溯越容易。可改变性：是指对软件作出修改的容易程度。一是找到修改点的难度；二是修改对软件的其他部分造成影响的程度。稳定性：修改局部代码不应产生过多的不良后果 （封装、数据隐藏、分离组件和服务、数据抽象和进行类型检查等手段）。可测试性：指一个软件能够被测试的容易程度。在一定的时间和成本前提下，进行测试设计、测试执行，发现软件存在的问题，以及对故障进行定位、隔离的能力特性。可测试性好的软件必然是一个强内聚、弱耦合、接口明确、意图明晰的软件。观感需求：观感需求主要描述对产品外观、风格的期望。环境与操作需求：设计之初就应该考虑要注意软件工作的具体环境。操作需求通常包括下列内容：操作环境，如系统和物理环境。用户的情况，如视力差等。伙伴或合作系统。安全性需求：主要关注什么不应该发生。两个来源可导致产生安全威胁一是开发人员在软件的设计和实现过程中出现的纰漏和错误。二是系统开发人员对软件面临的安全问题考虑不够充分、不够完整。设计限制来源：某些必须的设计选项的限制。开发过程自身的条件限制。法规及标准。非功能性需求的描述（用户故事）：作为一个用户，我想要在Windows95及其之后的任何版本上运行该产品。作为CTO，我想要软件能使用现有的订单数据库，而不是创建新的数据库，这样我们就不需要维护两个数据库了。作为一个用户，我想要这个网站在99.99%的想访问的时候可以访问它，这样我就不需要再麻烦地去找其它站点了。作为一个阿拉伯语的使用者，我想要使用这个系统。快速原型：使用快速原型进行反复交流、细化需求，就成为一种有效的技术。一个软件的原型，主要是模拟重要的功能和界面。一个软件的原型也可能是真实系统的一个模型或一部分，即真实功能的可视化显示或一部分，可能根本无法完成任何有用的功能。建立原型的目的：明确并完善需求。研究设计方案。发展为最终产品。确定系统的可行性。低保真原型：在纸上画的的草图或原型，也可以是在电脑上设计的产品页面。低保真原型的作用是表现产品中最重要的用户流程和功能所涉及的页面关系。展示产品的核心功能、信息架构以及页面间流程。确定产品UI的基本布局，例如确定页面元素和各部件的尺寸、位置以及页面中留白的使用情况。适合快速的头脑风暴，并向客户、开发和项目参与者演示设计想法，适合将一些早期的用户测试集成到产品设计中。　优点：设计人员对屏幕布局进行构思，不必关心布局中控件的精确位置及其外观，画出向最终用户显示的书面版本，设计各种各样的使用场景，分析人员可以根据用户的反馈，对原型进行快速充分的修改，理解用户如何与系统交互。由于创建低保真原型所需时间短、修改方便，因此，非常适合进行需求的探索、尝试和修改。开发团队不仅可以理解用户的真正需求，而且可获得潜在的需求。高保真原型：高保真原型是通过工具软件创建的，具有与软件产品相似外观。高保真原型展示的细节比低保真更深入细致，高保真原型是尽可能接近最终产品的样式。高保真原型比低保真原型更细节化，这让风险承担者有更多的机会探索用例的所有可能性。（1）进阶的页面设计。高保真原型的目标是对最终产品的讨论，包括在最终产品中看到的所有内容，例如产品的颜色、渐变、阴影、图形以及排版等。（2）进阶的互动原型和功能。高保真原型会进一步展示产品的动效情况，例如菜单、下拉列表、拖放等动效。还可能包含页面上移动的图形和动画，或者用户可以操作的元素。要点：（1）高保真原型要与最终产品高度一致。（2）轮播功能和交互功能。（3）高保真通常意味着带有色彩。区别：低保真和高保真原型之间的区别在于涉及的细节程度。故事板：开发人员可以把用户的需求看做是一个个需要讲述的故事。故事板可以将人们头脑中的概念转换成易于理解的实体，一个故事板“讲述一个特定的故事”。是一种获取解决方案表现方式、探究系统上下文，探索系统不同解决方案的方法。获取特定情景中系统功能逻辑和概念描述。故事板创建：建立的新功能（多要素复杂性）看做一个故事，将它分解为一系列的步骤或动作，故事板对每个步骤或动作的用户界面进行描述。故事板与原型：原型仅局限于屏幕环境的设计，忽略了屏幕之外的情景，故事板通过使用关键场景有助于理解屏幕之外的用户目标和动机。虚拟人物：虚构人物描述了一个虚拟的用户，它代表了一个基于真实用户的典型使用者。通过采用具有名称、个性、行为等特征的人，使这类用户成为鲜活的人物。创建虚拟人物目的：确保开发了用户群的所有需求。扮演一个用户，有助于对功能及其设计作出决策。使故事板集中于一个非常具体的用户背景（上下文）和目的。使用场景：使用场景描述一个人物如何与系统进行交互，从而执行一个特定任务。先决条件：明确问题。明确故事板制作的目的。明确故事板制作的类型。确定故事板应用在开发生命周期中的阶段。确定保真度。识别利益干系人的角色。识别限制条件。</p><h4 id="试题分析"><a href="#试题分析" class="headerlink" title="试题分析"></a>试题分析</h4><p><strong>一，给出软件项目背景，实验室预约背景（软件需求过程基础理论和技术）</strong>1.什么是软件需求过程？主要包括哪些阶段？每个阶段的工作目标是什么？ 一、软件需求过程是指在软件开发过程中，对软件需求进行识别、分析、规划、管理和验证的一系列活动。软件需求过程的主要目标是确保软件开发过程中所开发的软件能够满足用户需求和预期的功能，同时还要满足质量、性能、安全等方面的要求。二、需求获取：在这个阶段，与客户沟通，了解客户的需求，明确软件产品的功能、性能、质量等方面的需求。需求分析：在这个阶段，对需求进行详细的分析，梳理出软件产品的各项功能需求，制定详细的需求规格说明书。需求确认：在这个阶段，与客户确认需求规格说明书的准确性和完整性，确保需求符合客户的实际需求。需求验证：在这个阶段，通过验收测试等方式验证需求是否满足客户的实际需求。需求管理：在整个软件开发过程中，需要对需求变更、需求跟踪等进行管理，确保软件产品的需求得到有效的控制和管理。三、每个阶段的工作目标如下：需求获取：明确客户的需求，为后续的需求分析和设计提供基础。需求分析：详细分析需求，明确软件产品的各项功能需求，制定详细的需求规格说明书。需求确认：与客户确认需求规格说明书的准确性和完整性，确保需求符合客户的实际需求。需求验证：通过验收测试等方式验证需求是否满足客户的实际需求。需求管理：对需求变更、需求跟踪等进行管理，确保软件产品的需求得到有效的控制和管理。2.简答什么是业务需求，用户需求，系统需求？结合前文给出的项目背景，每类需求均举一个例子进行具体说明。 一、业务需求（Business Requirements）：指企业或组织在经营活动中所面临的问题或机遇，需要使用软件来解决或实现的需求。通常由企业高层管理者或业务人员提出，主要关注的是企业的战略、目标和利益，是软件开发的起点。用户需求（User Requirements）：指最终用户在使用软件过程中所需要的功能、性能、易用性等需求。通常由用户代表、产品经理或市场调研人员提出，主要关注的是用户在使用软件时的体验和需求。业务需求：即系统目标，描述组织的高层目标，从总体上描述为什么要开发系统。用户需求：用户需求描述用户使用产品必须要完成的任务，即描述用户使用系统能做些什么。通常通过对用户进行访谈、召开研讨会，对用户的工作场景进行整理，建立需求模型等，获得用户角度的需求。系统需求（System Requirements）：指软件系统在设计和实现过程中必须满足的功能、性能、安全性、可靠性等要求。通常由软件开发人员、架构师或系统管理员提出，主要关注的是软件系统的技术实现和可行性。二、业务需求：能够实现会议室的预定和使用计划的管理。具体而言，系统需要支持用户查询可用的会议室，预定会议室并记录预定信息，以及支持会议室使用计划的管理，包括预定状态、占用状态、使用时间等信息。用户需求：用户可能希望能够通过系统方便地查询和预定会议室，能够看到会议室的具体信息和可用时间，并且能够方便地取消预定。另外，用户可能希望系统能够提供多种预定方式，比如通过网页、手机应用或者语音指令等方式进行预定。系统需求：对于会议室智能管理系统，其中一个系统需求可能是：系统需要能够支持高并发的预定和查询请求，同时保证系统的响应速度和稳定性。另外，系统需要支持数据备份和恢复，以保证数据的安全性和可靠性。3.请简答什么是功能性需求，非功能性需求？结合前文，写出最重要的功能性需求和非功能性需求（会议室预约，管理）（并发性） 一、功能需求：规定了产品中必须实现的软件功能，用户通过这些功能完成各项任务，满足其业务需求。功能需求有时也被称为行为需求，因为它通常是对产品的一个行为进行描述。（对比静态的功能点，某个活动流程以及相关的串联的功能点）非功能性需求：指软件产品为满足用户业务需求而必须具有的除功能需求以外的特征和限制，它描述了产品必须具备的属性或品质。主要包括（质量属性，限制条件，外部接口）二、1功能性需求：预约会议室功能：系统能够提供在线预约会议室的功能，包括选择会议室、日期、时间、参与人员等信息，确保用户能够方便快捷地预约到符合自己需求的会议室。会议室管理功能：系统能够提供会议室管理的功能，包括会议室信息的录入、修改和删除，以及会议室使用状态的查询和统计，确保管理员能够方便地管理会议室，把控会议室的使用情况。会议提醒功能：系统能够提供会议提醒功能，通过短信、邮件、推送等方式提醒用户会议的时间、地点和议程等信息，确保用户不会因为遗忘而错过会议。2、非功能性需求：性能：系统应该能够在高峰期支持至少100个并发用户，并保持快速响应时间，响应时间不超过1秒。并发连接数：系统应该能够支持至少100个同时连接的用户。并发会话数：系统应该能够同时处理至少50个用户的会话。负载均衡：系统应该能够自动进行负载均衡，以确保系统资源的合理分配，负载均衡的时间不超过5秒。缓存机制：系统应该能够缓存至少1000条常用的数据，以提高数据访问速度，缓存时间不超过1小时。事务处理：系统应该能够支持至少10个并发事务，并确保事务的一致性和可靠性。错误处理：系统应该能够正确地处理至少99%的并发操作中出现的各种错误，并向用户提供相应的提示和解决方案。安全性：系统应该采取必要的安全措施，确保用户数据的安全性和隐私保护，系统应该支持用户登录验证和访问授权控制。可扩展性：系统应该具有良好的可扩展性，能够适应系统规模和负载的增长，系统应该支持水平扩展和垂直扩展。易用性：系统应该易于使用且直观，以便用户能够快速预约和管理会议室，并提供友好的用户界面和操作指南。可靠性：系统应该保证预约和管理过程的可靠性，以避免因系统失效而造成的会议延误或取消等问题，系统应该支持数据备份和恢复机制，确保数据的完整性和可用性。日志记录：系统应该记录所有用户的操作和系统的运行状态，以便系统管理员进行故障排查和系统性能优化。<strong>二，软件需求捕获和分析</strong>1.头脑风暴，产生初始用户角色，列出所有能想到的用户角色名称？为提炼后的角色建模，要求最后的用户角色 一、在进行头脑风暴时，我们可以尝试从不同的角度去思考可能的用户角色。以下是一些能想到的用户角色名称：学生，教师，教务管理员，信息技术(IT)支持人员，会议室管理员，外部讲师，校友，访问学者，校园安保人员，校园设施维护人员。二、经过进一步提炼，我们可以将用户角色确定为以下五个：学生，教师，教务管理员，信息技术(IT)支持人员，会议室管理员。三、现在，我们来分析每个角色的主要属性：学生：学号，姓名，所属班级，专业，电子邮件地址，预定会议室权限，预定历史。教师：教职工号，姓名，所属学院，专业方向，电子邮件地址，预定会议室权限，预定历史，课程安排。教务管理员：工号，姓名，电子邮件地址，系统管理权限，预定审批权限，用户管理权限，会议室信息管理权限。信息技术(IT)支持人员：工号，姓名，电子邮件地址，系统维护权限，硬件和软件故障处理权限。会议室管理员：工号，姓名，电子邮件地址，会议室管理权限，预定审批权限，会议室维护和清洁安排权限。2.针对研究生导师制订一份需求捕获方案（访谈计划或调查问卷）一、访谈计划：访谈时间：建议在工作日内，研究生导师方便的时间段，预计时间为1小时左右。访谈人员：项目团队成员、研究生导师。问题清单：您在使用会议室的过程中，最常遇到的问题是什么？您对现有的会议室预约系统有何评价？它是否满足您的需求？您对于会议室智能化管理系统的期望是什么？您认为在会议室智能化管理系统中，哪些功能是必须的？您对于会议室智能化管理系统的安全性有何要求？如果您是系统的管理员，您希望管理系统具备哪些权限和功能？您对于会议室智能化管理系统的用户界面和易用性有何要求？您希望系统是否能提供实时数据分析和报告功能？如果系统出现故障，您希望能够如何快速解决？您对于系统的使用方法和培训有何要求？二、调查问卷：您是否了解该大学会议室智能管理系统？您是否曾使用过该系统？如果使用过，您对该系统的使用体验和效果满意吗？您在使用会议室的过程中遇到过哪些问题？有哪些需求和建议？您对系统的预订会议室、管理预订信息、查看会议室状态和设备等功能有哪些期望和需求？您对系统的界面风格、布局、颜色等方面有哪些期望和建议？您对系统的数据安全和权限管理等方面有哪些期望和建议？您认为会议室智能管理系统对您的工作或学习有哪些帮助？<strong>三，需求规格编写</strong>1.编写用户故事，采用3C卡片，针对每一部分都给出完整且高质量的描述 卡片（Card）：作为一名研究生导师，我想能够方便地预约大学会议室，并获得会议室的实时使用情况，以便于更好地安排和组织学术活动。对话（Conversation）：研究生导师：我需要预约下周三下午2点到5点的会议室来举办一个小组讨论会，能否提供可用的会议室？系统：好的，我们的系统中有以下会议室满足您的需求：XX会议室、YY会议室和ZZ会议室。请问您需要预约哪一个？研究生导师：我需要预约XX会议室。系统：明白了，XX会议室在您需要的时间段内是可用的。请问您需要对该会议室进行何种设置？例如：是否需要投影仪、是否需要提供饮料等。研究生导师：我需要投影仪，其他不需要。系统：好的，投影仪已经为您预约好了。请注意，您需要在预约开始前15分钟到达会议室并进行签到，否则您的预约将会被自动取消。同时，在您使用会议室时，您可以通过我们的系统查看当前会议室的实时使用情况。研究生导师：那我如何查看会议室的实时使用情况呢？系统：您可以在系统中选择查看当前会议室的实时使用情况，系统会实时更新会议室的使用情况，并将其显示在您的屏幕上。研究生导师：好的，那我现在可以确认我的预约信息了吗？系统：是的，请确认您的预约信息。同时，我们会通过短信和邮件的形式提醒您预约的详细信息。确认（Confirmation）：研究生导师：确认预约信息无误。系统：已确认预约信息，谢谢使用我们的会议室预约系统。同时，祝您的学术活动顺利。卡片：作为一个大学教职员工，我希望使用智能管理系统来方便地预订和管理大学会议室，以提高会议室资源的利用效率。注释：用户角色：大学教职员工目标：方便预订和管理大学会议室，提高资源利用效率优势：简化预订流程，实时查看会议室可用性，自动化管理测试：测试1:给定一个大学会议室智能管理系统，当用户登录系统后，系统应显示可用的会议室列表。验证步骤：输入正确的用户名和密码登录系统。检查系统是否正确地显示了可用的会议室列表。预期结果：系统应正确地显示可用的会议室列表，包括会议室的名称、容量和当前可用性状态。测试2:给定一个大学会议室智能管理系统，当用户选择一个会议室并填写预订信息后，系统应成功地完成会议室预订。验证步骤：在系统中选择一个可用的会议室。填写预订信息，包括预订日期、时间、参与人数等。确认预订并检查系统的响应。预期结果：系统应成功地完成会议室预订，并显示预订成功的提示信息。测试3:给定一个大学会议室智能管理系统，当用户查看已预订的会议室时，系统应显示正确的预订信息和参与人员列表。验证步骤：登录系统并进入预订管理页面。查找已预订的会议室，并点击查看详细信息。检查系统是否正确显示了预订信息和参与人员列表。预期结果：系统应正确地显示已预订的会议室的详细信息，包括预订日期、时间、参与人数以及参与人员列表。2.将用户故事分解为可估计的开发任务，并估算该用户故事的规模（故事点）并给出估算依据。 以下是将用户故事分解为可估计的开发任务，并给出估算依据：1、根据预约信息查询可用会议室列表（2个故事点）：开发一个查询可用会议室的功能，该功能可以根据预约的时间段和会议室设备要求，返回可用的会议室列表。估算依据：这是一个中等规模的开发任务，需要设计查询算法和数据库查询语句。2、预约会议室（3个故事点）：开发一个预约会议室的功能，该功能可以根据用户的预约信息，预约指定的会议室，并将预约信息保存到数据库中。估算依据：这是一个较大规模的开发任务，需要设计预约流程、数据库表结构和相关的验证逻辑。3、查询会议室实时使用情况（2个故事点）：开发一个查询会议室实时使用情况的功能，该功能可以根据用户选择的会议室，返回该会议室的当前使用情况。估算依据：这是一个较小规模的开发任务，需要设计查询算法和数据库查询语句。4、发送预约短信和邮件提醒（2个故事点）：开发一个发送预约短信和邮件提醒的功能，该功能可以在用户预约成功后，向用户发送预约信息的短信和邮件提醒。估算依据：这是一个较小规模的开发任务，需要设计邮件和短信发送接口，并编写发送逻辑。5、总估算故事点数为9个故事点。估算依据为：根据开发任务的规模和难度，以及开发人员的工作效率，综合估算得到。其中，1个故事点约等于一名开发人员在一天内完成一项中等难度的开发任务所需的工作量。<strong>四，原型设计与需求管理</strong>1.选取一个功能，绘制低保真原型（纸上原型），并对原型中主要界面元素给出简要的文字描述。 以下是主要界面元素的简要文字描述：1、预约会议室页面：整个页面分为三个部分，分别是会议室信息、时间选择和设备选择。会议室信息部分显示了可预约的会议室列表，包括会议室名称、容纳人数、设备等信息。时间选择部分可以通过日历和时间段选择器选择预约的时间段。设备选择部分可以选择需要的设备，例如投影仪、音响等。2、会议室信息弹窗：当用户在预约会议室页面选择一个会议室后，点击该会议室的预约按钮，可以弹出一个会议室信息弹窗。该弹窗显示了该会议室的详细信息，包括会议室名称、容纳人数、设备、位置等。3、时间选择弹窗：当用户在预约会议室页面选择时间段时，可以通过点击时间段选择器弹出时间选择弹窗。该弹窗显示了可选的时间段，用户可以在弹窗中选择需要的时间段。4、设备选择弹窗：当用户在预约会议室页面选择设备时，可以通过点击设备选择器弹出设备选择弹窗。该弹窗显示了可选的设备列表，用户可以在弹窗中选择需要的设备。5、预约成功提示框：当用户成功预约了会议室后，会出现一个预约成功提示框，显示预约成功的信息，包括预约时间、会议室和设备等信息。同时，会提供返回和查看预约详情的操作按钮。2.团队遇到了需求变更情况，请简述你将综合运用哪些技术，如何实现对需求变更的管理。 1、敏捷开发方法：采用敏捷开发方法，将需求分解为可迭代的小块，每个迭代周期内只开发一个小块需求，以便于在开发过程中能够更好地适应需求变更。同时，敏捷开发方法还强调开发人员和用户之间的紧密合作，以便于及时获取用户反馈和需求变更信息。2、用户故事和原型设计：在需求变更时，采用用户故事和原型设计的方式，将用户需求转化为可视化的故事卡片和低保真原型，以便于开发人员和用户之间更好地理解需求变更内容和影响。同时，用户故事和原型设计也有助于在需求变更过程中及时发现和解决问题。3、版本控制工具：使用版本控制工具，如Git等，及时记录需求变更的内容和时间，并及时备份和恢复代码和文档，以便于在需求变更后能够更好地跟踪和管理代码和文档的变化。4、需求变更管理工具：使用需求变更管理工具，如JIRA等，管理需求变更的内容和状态，及时跟踪需求变更的进度和影响，以便于在需求变更过程中及时发现和解决问题。5、代码重构技术：在需求变更后，采用代码重构技术，对相关的代码进行重构和调整，以适应新的需求变更。同时，也要及时更新相关的文档和测试用例，以保证代码重构后的质量和可维护性。3.无论在哪种开发模型中，软件需求都被认为是一项非常重要的工作，结合本学期的实际项目经验，简述你对该观点的看法并对今后做好需求工作给出一些建议？ 我认为，软件需求确实是一项非常重要的工作，它直接决定了软件系统的功能、性能、可靠性和用户体验等方面，对于软件项目的成功与否起着至关重要的作用。在大学会议室智能管理系统的实际项目经验中，我也深刻体会到了软件需求的重要性。在项目启动阶段，我们花费了大量的时间和精力，与用户和领导进行沟通和交流，了解他们的需求和期望，细化需求并制定了详细的需求规格说明书。这些工作为后续的开发和测试工作奠定了坚实的基础，也保证了项目的顺利进行和交付。基于以上经验，我认为在今后做好需求工作中，可以采取以下建议：1、与用户和领导保持密切沟通：及时了解用户和领导的需求和期望，掌握他们的态度和想法，以便于更好地进行需求分析和规格说明。2、采用多种需求分析技术：例如用户故事、原型设计、数据流图等多种需求分析技术，以便于更全面地了解需求和涉众的期望。3、制定详细的需求规格说明书：制定详细的需求规格说明书，包括需求描述、功能需求、性能需求、界面需求等方面，以便于开发人员和测试人员更好地理解需求和进行开发和测试工作。4、及时处理需求变更：在项目开发过程中，可能会出现需求变更的情况，需要及时进行处理，以避免对项目进度和质量的影响。5、进行需求验证和确认：在需求规格说明书编写完成后，需要进行需求验证和确认，以确保需求的准确性和完整性，同时也有助于发现和解决需求规格说明书中的问题和不足。综上所述，做好需求工作对于软件项目的成功至关重要，需要采用多种需求分析技术、制定详细的需求规格说明书、及时处理需求变更、进行需求验证和确认等措施，以确保需求的准确性和完整性，为后续的开发和测试工作奠定坚实的基础。</p>]]></content>
      
      
      <categories>
          
          <category> 读书 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软件需求工程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>快来玩原神！</title>
      <link href="/post/11c899d3.html"/>
      <url>/post/11c899d3.html</url>
      
        <content type="html"><![CDATA[<p>这里是七种元素交汇的幻想世界“提瓦特”。<br>在遥远的过去，人们藉由对神灵的信仰，获赐了驱动元素的力量，得以在荒野中筑起家园。<br>五百年前，古国的覆灭却使得天地变异……<br>如今，席卷大陆的灾难已经停息，和平却仍未如期光临。<br>作为故事的主人公，你从世界之外漂流而来，降临大地。你将在这广阔的世界中，自由旅行、结识同伴、寻找掌控尘世元素的七神，直到与分离的血亲重聚 。</p><p>官网地址[<a href="https://ys.mihoyo.com/">《原神》官方网站-全新3.7版本 「决斗！召唤之巅！」上线！ (mihoyo.com)</a>]:</p>]]></content>
      
      
      <categories>
          
          <category> 游戏 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 原神 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>社会需要什么样的人</title>
      <link href="/post/3aac8915.html"/>
      <url>/post/3aac8915.html</url>
      
        <content type="html"><![CDATA[<p>物竞天择，适者生存。</p>]]></content>
      
      
      <categories>
          
          <category> 随想 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 社会 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DDos攻击</title>
      <link href="/post/8a5e2311.html"/>
      <url>/post/8a5e2311.html</url>
      
        <content type="html"><![CDATA[<h3 id="什么是-DoS-和-DDoS-攻击？"><a href="#什么是-DoS-和-DDoS-攻击？" class="headerlink" title="什么是 DoS 和 DDoS 攻击？"></a>什么是 DoS 和 DDoS 攻击？</h3><p>拒绝服务（DDoS）攻击和分布式拒绝服务（DDoS）攻击都是恶意的行为，利用大量互联网流量淹没目标服务器、服务或网络，破坏它们的正常运作。</p><p>DoS 攻击通过从单一机器（通常是一台计算机）发送恶意流量来实现这种破坏。形式可以非常简单；通过向目标服务器发送数量超过其有效处理和响应能力的ICMP（Ping）请求，发动基本的 Ping 洪水攻击。</p><p>另一方面，DDoS 攻击使用一台以上的机器向目标发送恶意流量。这些机器通常是僵尸网络（感染了恶意软件的计算机或其他设备的集合）的一部分，因而可以由单个攻击者进行远程控制。在其他情形中，多名个体攻击者可以串通起来，一起从各自的个体计算机发送流量来发动 DDoS 攻击。</p><p>DDoS 攻击在现代互联网中更为普遍，破坏性也更强，原因有二。首先，现代安全工具已经发展为能够阻止一些普通的 DoS 攻击。其次，DDoS 攻击工具已经变得相对廉价且易于操作。</p><h3 id="DoS-DDoS-攻击工具如何分类？"><a href="#DoS-DDoS-攻击工具如何分类？" class="headerlink" title="DoS/DDoS 攻击工具如何分类？"></a>DoS/DDoS 攻击工具如何分类？</h3><p>市面上有诸多工具可以通过调整来发动 DoS/DDoS 攻击，或者明确设计用于此类目的。前一类工具通常是“压力源”，宣称的用途是帮助安全研究人员和网络工程师对自己的网络进行压力测试，但也可用来发动真正的攻击。</p><p>一些工具属于专用工具，仅关注 OSI 模型的特定层；另一些工具则设计为允许使用多种攻击手段。攻击工具的类别包括：</p><h4 id="低速缓慢攻击工具"><a href="#低速缓慢攻击工具" class="headerlink" title="低速缓慢攻击工具"></a>低速缓慢攻击工具</h4><p>顾名思义，此类攻击工具仅使用少量数据，而且运行速度非常慢。设计用于通过多个连接发送少量数据，以便尽可能确保目标服务器端口长时间处于打开状态；这些工具将不断占用服务器资源，直到服务器无法维持其他连接为止。独特之处在于，即使不使用僵尸网络这样的分布式系统，低速缓慢攻击有时也可能会得逞，并且通常由一台机器来发动。</p><h4 id="应用程序层-L7-攻击工具"><a href="#应用程序层-L7-攻击工具" class="headerlink" title="应用程序层 (L7) 攻击工具"></a>应用程序层 (L7) 攻击工具</h4><p>这类工具以 OSI 模型的第 7 层为目标，基于互联网的请求（例如 HTTP）在这一层上发生。恶意用户可以利用某种 HTTP 洪水攻击，通过 HTTP GET 和 POST 请求淹没目标，从而发起攻击流量，使其很难与实际访问者提出的正常请求区分开来。</p><h4 id="协议和传输层-L3-L4-攻击工具"><a href="#协议和传输层-L3-L4-攻击工具" class="headerlink" title="协议和传输层 (L3/L4) 攻击工具"></a>协议和传输层 (L3/L4) 攻击工具</h4><p>此类工具深入协议堆栈，利用 UDP 等协议向目标服务器大规模发送流量，例如在 UDP 洪水攻击期间。虽然单独使用通常不起作用，但此类攻击常常以 DDoS 攻击的形式出现，增加参与攻击的机器数量可加大攻击效果。</p><h3 id="常用的-DoS-DDoS-攻击工具有哪些"><a href="#常用的-DoS-DDoS-攻击工具有哪些" class="headerlink" title="常用的 DoS/DDoS 攻击工具有哪些?"></a>常用的 DoS/DDoS 攻击工具有哪些?</h3><p>一些常用的工具包括：</p><h4 id="低轨道离子炮-LOIC"><a href="#低轨道离子炮-LOIC" class="headerlink" title="低轨道离子炮 (LOIC)"></a>低轨道离子炮 (LOIC)</h4><p>LOIC 是一款开源压力测试应用程序。提供了对用户友好的所见即所得型界面，可被用来发动 TCP 和 UDP 协议层攻击。鉴于原始工具广为流传，现已演化出多种衍生工具，可被用来通过 Web 浏览器发动攻击。</p><h4 id="高轨道离子炮-HOIC"><a href="#高轨道离子炮-HOIC" class="headerlink" title="高轨道离子炮 (HOIC)"></a>高轨道离子炮 (HOIC)</h4><p>此类攻击工具用于取代 LOIC，不仅扩展了功能，还新增了自定义项。采用 HTTP 协议后，HOIC 可以发起难以缓解的针对性攻击。这款软件设计为集合至少 50 人就能发起协同攻击。</p><h4 id="Slowloris"><a href="#Slowloris" class="headerlink" title="Slowloris"></a>Slowloris</h4><p>Slowloris 是一款针对目标服务器发动低速缓慢攻击的应用程序。只需占用相对有限数量的资源，便可产生破坏性效果。</p><h4 id="R-U-D-Y（死亡之子）"><a href="#R-U-D-Y（死亡之子）" class="headerlink" title="R.U.D.Y（死亡之子）"></a>R.U.D.Y（死亡之子）</h4><p>R.U.D.Y. 也是一款低速缓慢攻击工具，它的设计可使用户运用简洁的点击式界面来轻松发动攻击。此类攻击会打开多个 HTTP POST 请求，并尽可能确保这些连接长时间处于打开状态，从而慢慢压垮目标服务器。</p><h3 id="如何防御-DoS-DDoS-工具？"><a href="#如何防御-DoS-DDoS-工具？" class="headerlink" title="如何防御 DoS/DDoS 工具？"></a>如何防御 DoS/DDoS 工具？</h3><p>既然 DoS 和 DDoS 攻击采取多种不同的形式，缓解它们也需要不同的策略。阻止 DDoS 攻击的常见策略有：</p><ul><li>速率限制：限制服务器在特定时间范围内接受的请求数量</li><li>Web 应用程序防火墙：使用工具来基于一系列规则过滤 Web 流量</li><li>Anycast 网络扩散：在服务器和传入流量之间置入一个大型分布式云网络，以提供额外的计算资源来响应请求。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DDos </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>软件过程复习</title>
      <link href="/post/31567ae7.html"/>
      <url>/post/31567ae7.html</url>
      
        <content type="html"><![CDATA[<ul><li><p><strong>软件过程基本理论与技术（40）（CMM，RUP,迭代开发，敏捷开发，XP,Scrum,软件构建，重构技术，配置管理,过程评价）</strong>过程的定义IEEE-Std-610定义“过程”是为完成一个特定的目标而进行的一系列操作步骤，如软件开发过程。SEI－CMM 定义过程是用于软件开发及维护的一系列活动、方法及实践! 软件过程的分类和组成软件基本过程：软件获取、供应、开发、运行和维护的过程，包括需求分析、软件设计、编码等过程。软件支持过程：对软件主要过程提供支持的过程，包括文档编制过程、配置管理过程、质量保证过程、验证和确认过程（测试过程）、评审过程等。软件组织过程：对软件主要过程和支持过程的组织保证过程，包括管理过程、基础设施过程、改进过程和培训过程。过程规范 就是对输入/输出和活动所构成的过程进行明文规定或约定俗成的标准。软件过程规范 是软件开发组织行动的准则与指南，可以依据上述各类过程的特点而建立相应的规范，如软件基本过程规范、软件支持过程规范和软件组织过程规范。为什么需要软件过程即使软件开发团队拥有了最先进的编程技术和工具支持，也不一定能够保证软件项目的成功；而采用什么样的过程将人力、技术、方法、工具等要素有机结合起来逐渐成为关系到项目成败的重要因素，因此也逐渐出现了对“软件过程”的研究<strong>。</strong>软件是抽象的 软件没有生产流水线。软件是不断更改的。软件的质量难以控制软件开发过程是指在完成某个软件项目的过程中，开发目标软件所经历的步骤，是一系列软件活动的集合。软件工程过程有两方面的含义：一是指为了指导和控制软件开发过程，经总结、抽象形成的一组规范的集合；二是指一门专门研究软件开发过程的学科，即“研究过程的工程”。软件工程过程是按照软件工业化的标准定义的在软件开发中必须具有的一系列过程规范；软件工程过程是定义软件中的软件需求、软件设计，软件编码、软件测试、软件部署的实现目标和规范化的管理方法论；软件工程过程是保证软件工业化生产的法典；软件工程过程做的是：定义标准和为了达到标准的路；软件工程过程要改善的是：软件开发的效率和质量；软件工程过程的实现最重要的是：人软件过程的比较CMM也是一个标准，它要求我们应该做到什么，而没有告诉我们应该如何做 。XP告诉我们如何做，但是没有明确的指出，做到以后该如何改进；ISO9001是工业标准，但是不是软件业的工业标准；RUP和CMM结合，把RUP的九个工作流和CMM2、3级的KPA结合起来是一种趋势；UML成为交流的工具软件过程理论的基石：软件产品和服务的质量，很大程度上取决于生产和维护该软件或者服务的过程的质量。软件过程改进框架：软件过程改进环境（软件过程改进架构，软件过程改进计划，软件过程改进规划图，软件过程评估办法）I: Initiating 开始 D: Diagnosing 诊断、评价 E: Establishing 建立A: Acting 执行 L: Leveraging 调整PSP着重于软件开发人员的个人能力提升，体现在估算能力、计划能力、计划执行以及质量管理等方面。PSP作用个人级别估算和计划。承诺和拒绝承诺。理解和改进。工业水准的过程和规范。客观决策的数据。PSP是包括了数据记录表格、过程操作指南和规程在内的结构化框架。一个基本的PSP流程包括策划、设计、编码、编译、单元测试以及总结等阶段。在每个阶段，都有相应的过程操作指南，用以指导该阶段的开发活动所有的开发活动都需要记录相应的时间日志与缺陷日志。PSP基本原则软件系统的整体质量由该系统中质量最差的某些组件所决定； 软件组件的质量取决于开发这些组件的软件工程师，更加确切的说，是由这些工程师所使用的开发过程所决定；作为合格的软件工程师，应当自己度量、跟踪自己的工作，应当自己管理软件组件的质量；作为合格的软件工程师，应当从自己开发过程的偏差中学习、总结，并将这些经验教训整合到自己的开发实践中，也就是说，应当建立持续地自我改进机制。TSP能够提供了 ①一个已经定义的团队构建过程；②一个团队作业框架； ③一个有效的管理环境。TSP启动过程：商业目标-分配角色-产品开发策略-整体计划-质量目标-分期计划-风险评估-准备管理评审-管理评审-评估启动过程TSP（团队软件过程）：是为开发软件产品的开发团队提供指导，TSP的早期实践侧重于帮助开发团队改善其质量和生产率,以使其更好的满足成本及进度的目标。21:TSP实践：①一个已经定义的团队构建过程②一个团队作业框架。③一个有效的管理环境22:团队软件过程TSP基于以下4条基本原理:①应该遵循一个确定的、可复的过程并迅速获得反馈，这样才能使学习和改革最有成效;②一个群组是否有效，是由明确的目标、有效的_工作环境、有能力的教练和积极的领导这4方面因素的综合作用所确定的，因此应在这4个方面同时努力，而不能偏废其中任何一个方面;③应注意及时总结经验教训，当学员在项目中面临各种各样的实际问题并寻求有效的解决问题方案时，就会更深刻地体会到TSP的威力;④：应注意借鉴前人和他人的经验,在可知利用的工程、科学和教学法经验的基础上来规定过程改进的指令。RUP采用Use case的概念。RUP采用迭代的思想把系统的风险分布在四个阶段，风险越大的迭代越要放在靠前的阶段做;RUP的中心元素有三个1.用于成功开发软件的一组基本原则:这些原则是开发RUP的基础。2.可重用方法内容及流程构件块的框架:方法插件系列定义了方法框架，从该框架您可以创建自己的方法配置及定制的流程。3.底层方法及流程定义语言:统一方法体系结构元模型提供了用于描述方法内容及流程的语言。认识MSF1)它是一种框架结构1一种帮助提供技术决策指南的观点。2一组反复跟踪、监控和管理项目及其进展的参考方法。3一致的重用性保证在灵活的计算环境中有效的利用已有的知识和技能2)一个资源的集合1联机资料2.CD-ROM知识库3.教学课程4完整的参考手册3)它在不断发展RUP与MSF比较1.MSF不错的过程方法,简单，实用，线条清晰。2.RUP整体更具备严谨性，和适应性。3.RUP提供了一套丰富的被在工业中清晰定义和良好理解的术语集合4.MSF依赖于微软特定的文化和人员素质特性，使用MSF实践需要企业文化的改变以及项目团队成员的承诺和投入5.MSF中的一些过程方法可以按照UMA的方式整合企业自己的方法体系中RUP 产品开发时考虑了两组主要用户: 作为项目团队一部分的软件开发执行人员，包括项目干系人/过程工程执行人员，尤其是软件过程工程师和经理。为什么要使用RUP？1.RUP 向软件开发执行人员提供了一种基于标准，但又可以配置的流程环境。该流程环境：允许发布已定制的方法，并可供整个项目团队访问/允许按每个项目的独特需要对方法进行配置/向每个用户提供定制过滤2.RUP本质上是软件工程实践的集合体，这些实践将不断地定期改善以反映行业实践变化。 对项目干系人。RUP提供了一个术语词汇表和一个知识百科全书，以帮助您向软件开发团队有效地传达您的需要。 对软件开发执行人员。RUP提供一个核心的、通用的流程定义，确保队员可以共享该定义，这样有助于改善团队沟通。RUP在软件开发实践中提供了丰富的指导。对经理或团队负责人。RUP向您提供一个流程，您可以通过该流程与员工进行有效地沟通，以及相应地管理和控制他们的工作。对流程工程师。RUP向您提供很好的体系结构基础和大量的材料，您可以用它们来构造您的流程定义。业务驱动开发的6个原则：提高过程的适应性；平衡有竞争的涉众的优先级；团队协作；体现迭代的力量；提升抽象级别； 持续关注质量RUP9个规程需求规程、业务建模规程、配置和变更管理规程、环境规程、项目管理规程、分析与设计规程、实施规程、测试规程、部署规程RUP的6个最佳实践：迭代开发；管理需求；使用基于组件的构架；可视建模；持续的质量验证；控制变更。迭代开发先启阶段：确定项目范围和边界条件；确定用例和主要场景，将会驱动权衡主要的设计；对一些主要场景展示候选架构；估量总时间和费用；找出潜在的风险(不可预测的资源)；为项目准备环境支持；评估标准：项目干系人参与的范围定义与成本和进度估算。捕获一组正确的需求并且对这些需求有共同的理解。成本和进度估算、优先权、风险和开发过程必须是恰当的。已经识别所有的风险并且存在一个可以解决该风险的对策。精化阶段：尽早的定义、确认架构基线；确定架构的风险；确定愿景；为构造阶段创建一个详细的计划；证明架构基线在合理的时间、合理的成本内符合愿景；细化的支持环境评估标准：稳定的产品愿景和需求 。稳定的架构。关键的测试和评估；指出并且解决主要的风险元素。构造阶段：为移交阶段完成软件产品。优化资源、避免不必要的报废和返工，最小化开发成本。尽可能快的达到质量标准。尽可能快的实现可用的版本(alpha, beta和其他测试版本) 评估标准：产品是否能够在用户中稳定地发布并且成功的部署？是否所有的项目干系人都准备好把产品移交到用户？实际资源支出是否于计划中的相符？移交阶段：实现用户的自营。实现项目干系人赞同与评估愿景一致来完成基准线的部署。在一个快速和高效益的方式下完成最后的产品基线确定。评估标准：用户是否满意? 实际资源支出是否在计划支出的范围内？什么是迭代：一个有基线计划的不同顺序的活动，或者能够产生一个产品的发布的评价标准（内部或者外部）。迭代是通过了多个阶段。各阶段的交付产品各不相同，这取决于它们所在的生命周期和项目的性质。一个迭代可以看做是有计划、可交付、可评估的的小项目。并且这些项目的评估和修正也适合于剩余的项目。影响迭代持续时间的因素：大小、稳定性和组织成熟度；熟悉迭代过程；项目的大小；技术简单的项目；用来管理代码、发布信息并且执行测试的自动化水平风险管理策略：风险回避—重组项目，以致于它不会受风险的影响。风险转移—重组项目，让别人承担风险。风险接受—承受，这意味着你必须视试着低风险，减小概率或者减轻影响并且找到一个应急计划 (“B计划”). 通过以下方法降低所接受的风险：创造一个风险列表工件。采取一些立竿见影、主动的措施来减小风险发生概率和减轻风险的影响。定义一个意外事件计划客观度量度量用来提供给开发团队：迄今为止进展情况的准确评估。深刻理解不断变化的软件产品的质量。依据成本和进度的估计完成产品。迭代开发中七个核心指标：管理指标：工作和进展（随着时间推移的工作）预算成本和支出（随着时间推移的费用）工作人员和团队动态（随着时间推移的人员变动）质量指标：改变通信量和稳定性（随着时间推移的通信量改变）缺陷和模块化（随着时间推移每个变更导致的缺陷）返工和适应性（随着时间推移每个变更导致的返工）平均故障间隔时间（MTBF）和成熟度（随着时间推移的故障率）RUP与敏捷敏捷方法使软件团队具有快速工作、快速响应变化能力，与RUP相比，敏捷模型在人员、方法、产品等方面的论述远不如RUP全面、详细。RUP是可配置过程，未给出对于特定项目（例如：有限资源和时间约束）的完整配置方案。RUP与XP-共性1基础都是面向对象方法2都采用迭代，增量开发方式3都是基于风险驱动4都重视代码、文档的最小化和设计的简化5采用动态适应变化的演进式迭代周期6强调需求和测试管理7鼓励用户积极参与RUP与XP-差异1.XP以代码为中心，编码和设计活动融为一体，弱化了架构的概念RUP过程通常以架构为中心，细化阶段的主要目的就是构造出一个可运行的架构原型，作为将来添加需求功能的稳固基础。2.XP有一个非常关键的假设就是:开发人员只注重眼前需求，依赖重构来适应需求的变动，这样所带来的风险、开销要小于需求变化使得事先充分设计失效的代价;反之，实施XP就是不明智的3.XP不包含业务建模、部署、过程管理等概念。4.RUP更加强调项目的可控性。5.可以将XP中的最佳实践纳入到RUP之中。6.RUP经过裁减后适合各种规模的项目，XP只适用于小团队。7.XP实践依赖团队成员的强关系而RUP对团队成员的关系紧密程度要求弱一些平衡敏捷和规范：1敏捷与规范，软件开发中看似对立的两个属性，实际上相得益彰。2计划驱动的开发人员必须敏捷，敏捷开发人员必须规范。成功的关键在于找到两者的平衡点。3这个平衡点随项目所处的环境以及所涉及的风险而变化。仅凭一腔热情径直地采用极端方法的开发人员，必须学会如何根据实际情况恰当地平衡敏捷与规范。敏捷宣言：个体和迭代，超越过程和工具；工作的软件，超越完整的文档；客户协作，超越合同谈判；响应变更，超越履行计划敏捷过程：个体和交互胜过过程和工具。可以工作的软件胜过面面俱到的文档。客户合作胜过合同谈判。响应变化胜过遵循计划。XP的四个核心价值：沟通：问题往往是由于开发人员与设计人员、设计人员与客户之间的沟通不畅造成的。简单：应该尽量保持代码的简单，只要它能工作就可以与其实现一个复杂的的系统，不如设计一个能够满足目前需要的、简单的系统，因为你所考虑的情况可能永远都不会发生。反馈：尽快获得用户的反馈，并且越详细越好，使得开发人员能够保证自己的成果符合用户的需要。勇气：这是最重要的核心价值。因为XP强调要”拥抱变化”，因此对于用户的反馈，要勇于对自己的代码进行修改，丢掉坏的代码。极限编程的原则：1．所有的代码都必须有单元测试 2．所有的代码在发布之前必须通过所有单元测试 3．当一个BUG发现时，就增加新的测试 4．经常运行验收测试，并公布分数 推荐工具：Junit结对编程就是由两名开发人员在同一台计算机上共同编写解决同一个问题的程序代码，通常一个人编码，另一个人对代码进行审查与测试，以保证代码的正确性与可读性。结对编程是加强开发人员相互沟通与评审的一种方式。Scrum: 是一种迭代式增量软件开发过程，通常用于敏捷软件开发。虽然Scrum是为管理软件开发项目而开发的，它同样可以用于运行软件维护团队。什么是敏捷软件开发?<strong>1.</strong>敏捷软件开发是软件项目的一个概念框架.有许多建立在敏捷概念上的方法，如 Scrum 和 Extreme Programming (XP).2.与僵化的、重量级的、官僚式的方法形成对照，比如瀑布模型（指纯粹形式的）3.最大限度地降低短期固定时间的迭代式软件的开发风险.敏捷过程的限制1.敏捷软件开发过程包含过程、原则、工具和最重要的-人2.因此诚信是基础3.没有过程能够对诚信进行有效地约束4.诚信与否是有效实施敏捷过程的最大限制传统项目管理：事先对整个项目进行估计、计划、分析。反对变更; 变更需要重新估计、重新规划。严密的合同来减少风险, 如果改变需求要走 CR 流程.。项目作为一个“黑盒子” ，对客户与供应商的可视性差.。产品化和测试阶段是分离的.。文档和计划驱动的方法.。软件交付时间晚, 意识到风险的时间晚敏捷项目管理:对整个项目做一个粗略的估计,每一次迭代都有详细的计划.鼓励变化, 客户价值驱动开发.信任和赋予权力;合约使变更变得简单，增加价值.客户和开发人员之间是紧密的连续的合作关系。每次迭代都产生可交付的软件。专注于交付软件。第一次迭代就可交付能工作的版本，风险发现的早. 敏捷原则：1. 优先级最高的是，通过早期和持续交付有价值的软件来满足客户。 2. 欢迎变更需求，即使在开发的后期提出。敏捷过程为客户的竞争优势而控制变更。 3. 以两周到两月为周期，频繁地交付可运行的软件，首推较短的时间定量。 4. 在整个项目过程中，每一天开发人员都要和业务人员合作。 5. 由个体推动项目的建设，为个体提供所需的环境，支持和信任。 6. 在开发团队中或开发团队间传递信息的最为有效和高效的方法是面对面的交谈。 7. 衡量进展的重要尺度是可运行的软件。 8. 敏捷过程提介可持续的开发。 9. 发起人，开发者和用户应该步调一致。 10.不断地关注技术上优越的设计会提高敏捷性。 11.简洁是最重要的，简洁就是尽量减少工作量的艺术。 12.最佳的架构，需求和设计来自于自组织的团队。 13.团队要定期反省如何使工作更有效，然后相应地调整行为。敏捷的项目有三个主要阶段 :产品定义 (规划); 运行Sprints 所需要的准备、规划、技术分析。执行Sprints (执行): 在增量时间段内实现 需求 (产品需求清单)。结束: 准备最终发布，结束项目Scrum的最佳实践1迭代式软件开发方法2两层项目规划3团队的整体协作能力（Whole Team）4软件持续集成原则。Scrum开发过程三个要素1角色2活动3工件Scrum中的三种角色1.Product Owner- 产品所有者 个人：代表所有的干系人2.Scrum Master: 个人：负责指导过程的执行3.Scrum Team – Scrum团队:承诺完成工作，向干系人交付产品价值<strong>活动</strong>定义的主要活动包括冲刺规划会议（Sprint Plan Meeting）、每日站立会议（Scrum Daily Meeting）、冲刺复审会议（Sprint Review Meeting）和冲刺回顾会议（Sprint Retrospective Meeting）。<strong>工件</strong>在Scrum中，工件包括产品订单（Product Backlog）、冲刺订单（Sprint Backlog）、燃尽图（Burn Down Chart）、新的功能增量（New Functions Increment）等实体概念。自适应软件开发（Adaptive Software Development）着眼于人员协作和团队自我组织。包含思考、协作和学习三个阶段。敏捷常见误解：敏捷是拯救任何项目的银弹.（敏捷方法只有运用得当才有效果.）敏捷意味着ad-hoc hacking ，不需要任何文档.（敏捷是有严格要求的，也是面向质量的根据沟通的需要产生相应的文档.）敏捷只是开发者的问题（基本的开发方法与传统相比有显著不同, 影响项目的各个方面: 合同, 角色, 定价模型, 项目管理等.）采用敏捷方法的开发组/项目不需要制定计划（敏捷项目需要经常制定计划，但是不需要试图超前制定项目计划，通常这也是不可能的.）敏捷项目的范围可以随时改变.（变更可以等到下一次迭代开始，当前正在进行中的迭代不能变更）只对小项目适用（在中型和大型的项目中一样取得了成功）软件构建技术：软件构建指的是通过编码、验证、单元测试、集成测试和调试的组合，详细地创建可工作的、有意义的软件。软件构建具体包含什么活动，是由采用的生命周期过程所决定的。 在经典的生命周期模型中，软件构建过程活动包含了软件编码相关活动、部分详细设计活动和部分软件测试活动。 在敏捷模型中，软件构建过程是与其他软件开发过程（计划、需求、设计等）并行或重叠进行的，这时更倾向于将设计、编码和测试活动组合起来称为“构建”活动。软件构建原则：最小的复杂性。要预测变更。为验证而构建。构建方式：手工构建（通过javac编译代码）通过IDE构建（eclipse自动编译）通过自动化构建工具（maven和ant自动构建）要考虑的问题：在软件构建过程中，要充分考虑到软件的质量，提高其可复用性、可维护性，主要考虑的方面有：持续集成。软件重构。软件复用和质量。软件重构技术：软件重构是在不改变代码外在行为的前提下，对代码进行修改以改进程序的内部结构，即软件重构只是将软件的内部结构进行调整，提高其可理解性，降低修改的成本。重构时间：“三次原则”可以作为重构时机的参考，即“事不过三，三则重构”。也就是说，第一次编写全新的代码尽管去做；第二次编写类似的代码虽然令人反感，但还是直接去做；第三次再做类似的事情，这时就应该重构。不需要重构：重构也不是随意的活动，除了存在必须重构的情况，同时也有一些不允许重构的情况，例如： 程序原型不能重构；代码不能正常工作时不需要重构；在项目接近尾声时不能重构；重构方法：重新组织函数。在对象之间迁移特征。重新组织数据。简化条件表达式。简化函数调用。处理概括关系。大型重构。软件测试技术 软件测试就是利用测试工具按照测试方案和流程对产品进行功能和性能测试，甚至根据需要编写不同的测试工具，设计和维护测试系统，对测试方案可能出现的问题进行分析和评估。执行测试用例后，需要跟踪故障，以确保开发的产品适合需求。Junit测试工具 JUnit是一个开放源代码的Java测试框架，用于编写和运行可重复的测试。他是用于单元测试框架体系xUnit的一个实例（用于java语言）。它包括以下特性：用于测试期望结果的断言（Assertion）。用于共享共同测试数据的测试工具。用于方便的组织和运行测试的测试套件。图形和文本的测试运行器。注意事项： 1.测试方法必须使用注解 org.junit.Test 修饰。2.测试方法必须使用 public void 修饰，而且不能带有任何参数。3.单元测试代码和被测试代码使用一样的包，不同的目录。4.注解 org.junit.Test 中有两个非常有用的参数：expected 和 timeout。5.org.junit.Ignore 用于暂时忽略某个测试方法，因为有时候由于测试环境受限，并不能保证每一个测试方法都能正确运行。先说说软件配置管理的定义及目的，再解释以下软件配置管理的相关术语软件配置管理是一个辅助性的软件生命周期过程，对软件项目进行版本控制、变更管理等活动，能够记录软件任一时刻的状态并支持回溯。软件配置管理的目的，是通过将错误减少到最低来实现生产力的最大程度提高。1. 项目存储库：存放所有项目所有资源的中心数据库。2. 流与组件流：是一个共享的开发区域，对应于某个开发团队。组件是一组相关文件或目录的集合。3. 变更集：变更集包含了对文件或目录个体内容的变更（例如删除、修改、转移等操作）。4. 基线与快照：基线就是组件的“版本”，代表的是某时某处某组件的状态。快照代表整个流的配置基线，可以是包含多个组件基线的组合基线。5. 主线与支线：通往最终产品的开发线。从主线分离出的独立开发线。配置管理的作用1.用于管理不断发展的软件项目或产品2.项目管理的重要辅助机制(减少人为错误/提高开发效率/保护项目资源)3.一种技术和策略相结合的管理手段(明确的过程和标准/高效实用的工具)敏捷开发中的配置管理敏捷开发对配置管理的更高要求:1.更协同的团队配置管理.更高的团队沟通效率。项目以及团队的组织架构、角色都应该与配置管理环节相关联。工具应该将项目、团队信息纳入管理环节。2.更协同的并行开发.并行开发中需要更多的协同能力，跨各个并行开发的信息应该是清晰的，可以灵活被传递的。3.完全基于任务的配置管理.配置管理应该以任务和变更为驱动，版本变化的目的与意义是任务和变更。同时，任务和变更会提高沟通效率、个人工作效率，提高变更响应速度4.开发过程与配置管理的紧密结合.配置管理中的开发过程与工具的紧密结合，过程控制的自动化提高团队协作效率，减少过重的流程要求，提高敏捷化。5.更高效的工作区模式.需要更高效的工作区开发模式，团队/个人的变化通知可以及时了解，主动性的接受与拒绝。过程评价：以一系列的标准对软件过程的质量进行评定而使软件过程不断改进和优化的系列活动。过程评价/过程评估：SEI在 “评价/评估指南”“评估指南”：当用户以过程改进为出发点，对自身机构的软件过程进行评定时：1.评定过程现有的过程能力2.预见其能力，潜在缺陷和改进方向。“评价指南” 仅是客观评定过程能力当时所达到的程度。无论是过程评价还是过程评估，其目的都是：认知过程能力、比较过程能力、改进过程能力。过程评价有多种实现方法，其中过程度量便是一种最有效且最系统化的方法，其他诸如问卷调查、实际走查（walk through）等也是实现过程评价的常用方法过程度量模型就是要研究过程度量所涉及的属性和问题，从而规范过程度量的内容和步骤，实现过程度量的目标。</p><p><strong>团队与团队文化建设（10）</strong>发挥团队智慧两大挑战：确定整体架构之前很难进行分工。鼓励团队成员在讨论和评审会议中的参与程度。团队设计面向整体开发，因此需要额外考虑如下内容：团队智慧的使用。设计标准。设计复用。设计的可测试性支持。设计的可用性支持等要求团队实现策略：评审的考虑。复用策略。可测试性考虑集成策略选择：大爆炸集成策略。逐一添加集成策略。集簇集成策略。扁平化集成策略。团队项目规划– 工作分解结构– 开发策略与计划– 生命周期 模型– 日程/质量/风险计划团队项目跟踪与管理– 挣值管理– 里程碑评审– 纠偏活动管理WBS作用范围基线/提供整体观/不遗漏可交付物/明确各个角色的责任/工作包定义/估算和计划的基础/理解工作，分析风险创建WBS方法1识别和分析可交付成果及相关工作2确定工作分解结构的结构与编排方法3自上而下逐层细化分解4为工作分解结构组成部分制定和分配标志编码5核实工作分解的程度是必要且充分的好的WBS检查标准1最底层要素不能重复，即任何一个工作 包应该在WBS中的一个地方且只应该在 WBS中的一个地方出现2所有要素必须清晰完整定义，即相应的数据词典必须完整定义3最底层要素必须有定义清晰的责任人， 可以支持成本估算和进度安排4最底层的要素是实现目标的充分必要条件，即项目的工作范围得到完整体现范围管理包括确保项目做且只做成功完成项目所需的全部工作的各过程.WBS为范围管理提供了基准.1收集需求2定义范围3创建WBS 4核实范围5控制范围变更人员角色评审-项目组长• 项目组长的角色评审应当从领导力角度开考察团队的表现。• 重点关注团队激励和团队承诺方面的问题。• 项目会议的组织情况也需要总结。比如，会议效果、讨论技巧等。• 此外，还应当就如何在下一周期做得更好提出改进建议。人员角色评审-计划经理• 计划经理主要关注项目进度，因此，在总结阶段需要就估算、生产效率、里程碑等话题进行总结。人员角色评审-开发经理• 开发经理进行总结的时候，应当从开发内容和开发策略角度出发，总结得失。人员角色评审-质量经理• 质量经理的总结则应该从项目整体质量状况出发，总结质量目标的实现过程，并找出改进机会。人员角色评审-过程经理• 过程经理关注团队遵循过程的程度和过程改进方案。因此，在项目总结阶段，过程经理需要总结的问题为：– 是否所有人都如实记录数据？人员角色评审-支持经理• 支持经理主要关注配置管理状况、问题和风险跟踪机制以及复用策略的支持等话题。因此，在项目总结阶段，支持经理需要总结的问题为：– 项目团队开发环境是否合用？人员角色评审-工程师• 此外，由于大部分角色经理同时充当着软件工程师的角色，因此，还需要就工程师角色的工作状况进行总结。工程师重点关注的就是个人的绩效（生产效率、质量水平等）。因此，需要总结的问题包括：– 个人计划的绩效与实际的绩效有没有差别？自主团队具备如下的特点：– 自行定义项目的目标– 自行决定团队组成形式以及成员的角色– 自行决定项目的开发策略– 自行定义项目的开发过程– 自行制定项目的开发计划– 自行度量、管理和控制项目工作自主团队的外部环境:项目启动阶段获得管理层的支持。在项目进展过程中获得管理层的支持承诺文化的建立与团队激励通常用以激励团队成员的方式有三种：“威逼”、 “利诱”以及鼓励承诺按照马斯洛关于人的需求层次的理论， 人的需求大致分成五个不同的层次。– 第一层：生理需求– 第二次：安全感– 第三层：爱和归属感– 第四层：获得尊敬– 第五层：自我实现角色经理 团队领导者告知 倾听、指导 询问、说服 激励/挑战、决定 促进达成一致、控制 教练、监控 授权、设定目标 挑战团队文化是指团队成员在共同工作中形成的一种价值观、行为模式和社交规范。团队文化建设对软件工程过程至关重要，因为一个良好的团队文化可以促进协作、提高生产力和创造优秀的软件产品。以下是团队文化建设的贡献情况说明：促进团队合作良好的团队文化可以鼓励团队成员之间相互信任和支持。团队成员会更倾向于分享知识，并且能够更好地协作完成任务。这有助于减少项目延迟和错误，促进团队效率和成功。提高工作动力一个积极、充满活力和友好的团队文化可以激励成员参与工作和增强工作动力。成员们会更愿意投入时间并尝试新的想法和方法。打造创新氛围团队文化对于推动创新也非常重要。当团队成员从不同背景和专业领域汇集在一起时，他们能够交流各自的经验和知识，激发出新的想法和创新。建立共同价值观团队文化还有助于建立共同的价值观。这意味着成员将会更容易接受并实施项目目标和价值观，并且能够更好地了解其他成员的需求和期望。提高工作满意度良好的团队文化可以提高成员的工作满意度。这是因为成员与团队共享相似的价值观和目标，同时也能够获得尊重和支持，从而增强他们对工作和团队的投入感和忠诚度。</p><p><strong>过程环境与支持管理（15）</strong>软件过程环境以过程为中心的组织-软件过程架构-软件过程实施-软件过程评估-软件过程改进软件过程文化过程至上，奉过程为教条，一切围绕着过程，组织、质量和效率都服从于过程，过程的执行严格，过程结果可靠、稳定，认为生产的“东西”是过程的一个节点，只是全局的一部分。但效率较低，缺乏灵活性、创造性。2以过程为焦点，关注过程，强调过程的重要性，但不拘于过程，让过程服从于质量和效率、服从于组织的业务目标……</p><p>3过程只能起辅助作用，人决定一切, 过程可能流于形式…项目管理过程 是计划、跟踪和协调项目执行及生产所需资源的管理过程。项目管理过程的活动，包括软件基本过程的范围确定、策划、执行和控制、评审和评价等。质量管理过程 是对项目产品和服务的质量加以管理，从而获得最大的客户满意度。此过程包括在项目以及组织层次上建立对产品和过程质量管理的关注风险管理过程，在整个项目的生命周期中对风险不断的识别、诊断和分析，回避风险、降低风险或消除风险，并在项目以及组织层次上建立有效的风险管理机制子合同商管理过程，选择合格的子合同商并对其进行管理的过程。<strong>软件组织过程</strong>业务规划过程 是为组织与项目成员提供对愿景的描述以及企业文化的介绍，从而使项目成员能更有效地工作。定义过程 是建立一个可重复使用的过程定义库，从而对其它过程等提供指导、约束和支持改进过程 是为了满足业务变化的需要，提高过程的效率与有效性，而对软件过程进行持续的评估、度量、控制和改善的过程。人力资源和培训过程，为项目或其它组织过程提供培训合格的人员所需的活动基础设施过程 是建立生存周期过程基础结构、为其他过程建立和维护所需基础设施的过程。需求管理 需求确认，需求跟踪，变更控制。需求定义指的是解释涉众需求,并根据需求规模整理成对要构建系统的明确的说明。前景文档是用一般的语言定义系统特征的文档软件需求规格说明书是用更专业的术语定义系统特征的文档。项目管理项目管理就是将知识、技能、工具与技术应用于项目活动，以满足项目的要求。成功的项目管理是指在一定的时间和成本范围内，按一定的质量标准完成项目，并得到客户的认可。质量保证（Quality assurance）为使人们确信软件质量满足用户需要所必须的全部有计划有组织的活动。关注于过程改进。质量控制（Quality control）对开发过程中的软件产品的质量特性进行连续的收集和反馈，通过质量管理和配置管理等机制,使软件开发过程向着既定的质量目标发展。关注于项目软件产品。共同点：QC和QA都是为了保证产品的质量，都需要进行验证区别：</p><p>QC和QA的主要区别前者是保证产品质量符合规定；后者是建立体系并确保体系按要求运作，以提供内外部的信任。QA独立于QC之外，QA审查项目的质量控制是否按照指定的体系来完成。质量管理八大原则以顾客为中心；领导作用；全员参与；过程方法；系统的管理方法；持续改进；基于事实的决策方法；互利的供方关系质量管理规划质量管理 (启动过程组)实施质量保证 (实施过程组)实施质量控制 (执行过程组) 项目时间管理规划进度管理 (规划过程组)定义活动 (规划过程组)排列活动顺序 (规划过程组)估算活动资源 (规划过程组)估算活动持续时间 (规划过程组)制定进度计划 (规划过程组)控制进度 (监控过程组) 项目成本管理规划成本管理 (规划过程组)估算成本 (规划过程组)制定预算 (规划过程组)控制成本 (监控过程组)</p><p><strong>过程监控和度量（15）</strong>如何建立软件过程？从现有的成熟的软件生存周期模型中选择/对模型加以改进/自定义过程软件生命周期软件从诞生到消亡的整个生存过程六个主要过程：制定计划、需求分析、设计、程序编码、测试及运行维护软件过程包括:软件生命周期模型软件产品开发相关的过程、活动和任务的框架，这些过程、活动和任务覆盖了软件整个生存周期.传统软件生命周期模型瀑布模型（采用结构化的分析和设计方法将逻辑实现与物理实现分开。它将软件生命周期划分为计划、需求分析、设计、编码、软件测试和运行维护六个基本活动，并且规定了它们自上而下、相互衔接的固定次序，如同瀑布流水，逐级下落。优点：过程有计划分工明确 缺点：理想化，不灵活。产品交付延迟，反应慢）渐增模型（渐增模型通常采用“二次开发”的模式（通常以瀑布模型开发两次），优点在于缓解了瀑布模型不灵活，用户无法预判系统正确性的问题；缺点在于，需要严格、小心的控制过程，否则容易退化成“边做边改”模型，而且重复开发势必带来了成本上的增加。）螺旋模型（螺旋模型将开发过程分为几个螺旋周期，每个螺旋周期大致和瀑布模型的阶段相符合。每个螺旋周期可分为 4 个步骤： 第一，制定计划，即确定目标，选定实施方案，明确开发限制条件； 第二，风险分析，即分析所选方案，识别风险，通过原型消除风险； 第三，开发实施， 即实施软件开发； 第四，用户评估，即评价开发工作，提出修改意见，建立下一个周期的计划。螺旋模型加强了用户与开发人员的交流，兼有瀑布模型与演化模型的优点。尽管螺旋模型能够很大程度上保证产品是成功的，但却不能保证项目是成功的，进度、成本的压力使项目本身不可能无休止的重复。因此，风险分析是螺旋模型的核心活动，每次循环之前，都要评估下一次循环对项目产生的影响，保证项目的进度和成本在可控范围内。）喷泉模型（喷泉模型适合于面向对象的开发方法，它克服了瀑布模型不支持软件重用和多项开发活动集成的局限性。喷泉模型使开发过程具有迭代性和无间隙性。喷泉模型支持软件复用，有利于多项开发活动集成，但需要大量开发人员同时开发，不利于项目管理。使用喷泉模型时，文档必须严格管理以确保统一性。喷泉模型适用于使用面向对象开发方法的软件项目。）原型模型（原型模型以迭代式开发为思想，针对需求分析难以完整、准确，或者可实现性难以验证的问题，首先构建一个软件原始模型给用户体验，反馈意见，通过不断更新或者多次重复开发，得到最终软件。优点：易明确需求、易验证方案、用户快速体验与反馈缺点：需要工具和方法支持，以保障进度和成本）现代软件生命周期模型RUP模型/敏捷过程/微软解决方案框架软件过程的实施过程中要对软件过程进行管理，一方面要保证软件项目遵循已建立的过程，进度是可控的，这就需要采取一定的监控技术；另一方面，需要将过程进展情况量化以评估过程实施质量，即进行过程的度量，进而优化和改进软件过程。因此，过程管理是实时、持续的，贯穿项目始终。度量的客观性是指所得到的关于某对象的度量值是该对象的真实描述。度量的主观性是指所得到的关于某对象的度量值是由度量者的主观判断得到的，因此所得到的度量值会随度量者的不同而异。过程度量的意义过程度量能够为软件团队提供用于评估的参考，有助于帮助软件团队实施成功的过程、自我评价软件过程能力、积累经验并对过程进行改进。过程度量的对象 度量软件过程通常要关注的主要对象包括：过程自身、过程结果和活动。不同对象所要度量的内容和使用的方法略有不同。对过程自身的度量：要衡量软件过程本身的完成情况，常见的指标有进度、成本、工作量等软件过程的产生结果主要是各种软件工件，即文档、源程序等。主要的度量目标有：规模、结构和质量。规模最常用长度或功能来表示，例如模块中代码行数、文档页数、规格说明中的功能点数目等等。结构主要指软件架构，度量往往针对软件的模块结构、控制流、数据流、控制结构等方面的设计，以此来界定软件的复杂度。 质量有很多的评价准则，在软件工程发展过程中逐渐产生了一些成熟的质量模型，比较常见的有McCall模型、Boehm模型和ISO模型。度量活动是软件过程的基本组成部分，对活动的度量即是对成员行为的度量。过程监控原因：在实际软件开发过程中，往往会产生一些偏离过程的活动，例如工作效率过低、资源分配不足、突发事件等等。这些活动如果置之不理，势必会对原定的软件过程造成影响，软件过程监控就是为了确保软件过程能够高质量的运行而实施的一组活动。过程监控是否有效关键在于两方面：一方面是监控点的选择，即选择合理的监控时机；另一方面是监控内容的确定与验证。过程监控原则： 按里程碑监控：在软件过程的里程碑监控，可以对进度、结果质量等进行全面检查。 周期性监控：按固定的时间跨度进行监控，例如：每周进行一次检查。 按进度比例监控：根据项目的特点或者项目规模，规定每完成进度的多少比例时进行一次检查，例如：每完成进度的10%进行一次检查，那么在完成进度的10%、20%、30%……时进行检查。有了软件过程度量技术的支持，可以在多个层面对过程的执行质量进行检查，主要监控的内容有：进度。效率。过程结果。工作状态。进度：一个软件项目往往包含若干里程碑，在里程碑处可以检查项目是否滞后于计划进度。 效率：计划效率=计划工作量/计划工时，同理，实际效率=度量工作量/实际工时。项目经理在制定计划时，往往预先估计到达某个里程碑所需的工作量，从而得到计划效率。借助工作量度量技术，可以随时监控实际工作效率。 过程结果：即使工作量和进度达到了计划规定，也并不标志着执行了高质量的过程，还要检查过程结果（代码、文档等）的质量。监督过程结果需要借助软件质量度量技术 。工作状态：监督团队成员是否在按照计划执行任务，同时考察其工作积极性。隐患：检查资源（人力、成本、软硬件等）分配与占用情况，以防资源过早消耗对后续过程产生影响；如果发生突发活动（例如需求变更），那么要估计对现有过程产生的影响。1：Tsp的信息获取：①：需求获取②：需求汇总③需求验证④需求文档制作（形成一个完整的需求规格说明书）软件需求规范（SRS）：1：引言2：系统定义3：应用环境4：功能规格5：性能需求6：实现约束7：质量描述8：其他要求9：参考材料10：签字认证⑤团队设计（除了设计过程与PSP一致，还要考虑团队智慧的使用、设计标准、设计复用、设计的可测试性支持、设计的可用性支持等要求）⑥团队智慧⑦设计标准⑧复用性支持、可测试性考虑、验证与确认。2：RUP中的软件生命周期的四个阶段及对应里程碑：初始阶段：生命周期目标里程碑。细化阶段：生命周期结构里程碑。构造阶段：初始功能里程碑。交付阶段：产品发布里程碑。</p><p><strong>质量运动和过程改进（20）</strong>IDEAL模型：它描述了实现软件过程改进所必需的阶段、活动和成功的过程改进工作所需要的资源。IDEAL模型解决了软件组织在各种质量改进环境下的需要。它包括了软件过程改进周期中的五个阶段，IDEAL是代表这五个阶段的单词的首字母。过程改进与质量改进的关系质量改进是社会发展的原动力；过程改进是实现价值提升的基本方法过程成熟度标准软件过程能力；软件过程性能；软件过程成熟度2.1.1 软件过程不成熟的特点软件过程能力低，不能按预定计划开发出客户满意的产品，项目拖延、费用大大超出预算已成惯例。2过程性能的不可预见性，对进度和预算估计、产品质量的目标缺乏历史数据和有效方法的客观基础，开发的进度、成本和产品的质量都难以预测。3过程的不可视性，软件过程缺乏定义、缺乏文档和缺乏跟踪，在整个软件过程中，不清楚每个阶段进出的标准、执行的方法和规则。4过程的不稳定性，实际的、具体的操作过程是在一个项目开始后临时拼凑而成，每个项目都不一样。5过程的被动性、缺乏改进的主动性。2.1.2 软件过程成熟的标准软件过程能力高，具有全组织范围的管理软件开发和维护过程的能力。2软件过程性能可预见性，对进度、预算和质量做出现实的和准确的估计和预测。3软件过程规范化，可遵循的标准、规则和指导性原则。4过程的一致性5过程的丰富性6过程的可视性7过程的稳定性8过程的不断改进质量运动指的是一种旨在提高软件产品质量的方法论和实践活动。它强调通过对软件开发过程进行全面优化来提高软件产品的质量，而不是仅仅依靠测试和修补缺陷来达到这个目标。质量运动的主要目标是确保软件产品具有高度的可靠性、可维护性、可用性、安全性和可扩展性。为此，它通常会采取一系列措施，包括：强调敏捷开发、持续集成和持续交付等最佳实践，以确保软件开发过程的高效性和可追溯性。2引入代码审查、单元测试、集成测试、系统测试和用户验收测试等多个层次的测试机制，以确保软件产品的功能完整性和稳定性。3引入代码质量评估、性能测试、安全测试等专业工具，以确保软件产品的技术质量和安全性。4实行合理的需求管理、变更管理和缺陷管理体系，以确保软件产品的稳定性和可维护性<strong>。CMM</strong>为了改进过程，需要首先进行过程评估，找出当前过程运行能力的不足，然后提出改进措施。软件生产商通过软件评估，在保证业务目标的前提下，改进软件过程。软件过程改进的核心原则 软件过程改进的核心原则有五条，分别是：注重问题，强调知识创新，鼓励参与，领导层的统一，不断地改进。过程改进的关键是发现软件过程中所存在的问题和缺陷，而过程度量正是发现问题和缺陷的必备手段。软件过程改进模型 CMM不仅是评估模型，也是过程改进模型，其中定义了几种方法。两个实施和改进的一般模型：质量改进范例（Quality Improvement Paradigm，QIP）和启动—诊断—建立—行动—学习模型（IDEAL），过程实施的评价结果可以是定性的或定量的。过程改进的两种模式目标驱动模式。目标驱动的过程改进模式是指根据一个预先给定的目标，自顶向下制定过程度量或评价模型，有目的地开展相关改进活动的过程改进模式；缺陷驱动模式 缺陷驱动的过程改进模式是指根据过程实施时所产生的关于过程缺陷的反馈信息，进行有针对性改进活动的过程改进模式。RTC的主要功能包括以下方面：开发生命周期中的协作和集成。过程配置和定制。变更管理。计划。软件配置管理。构建自动化。报告。过程的基本概念 过程就是人们使用相应的方法、规程、技术、工具等将原始材料（输入）转化成用户需要的产品。过程的3个基本要素是：人、方法与规程、技术与工具。过程与产品存在因果关系。即好的过程才能得到好的产品，而差的过程只会得到差的产品。过程被文档化后才能成为规范。软件过程改进的根本目的是：提高质量、提高生产率并且降低开发成本。为了真正提高软件过程能力，企业至少要做三件最重要的事情： 首先制定适合于本企业的软件过程规范。对员工们进行培训，指导他们依据规范来开发产品。购买一些软件工程和项目管理工具，提高员工们的工作效率。文档太多怎么办 机构要下功夫制定出结构良好的文档模板，给出充足的提示和示例。这样使用者就可以“依葫芦画瓢”，总比他自己琢磨怎样写要方便得多。 提高开发人员的写作能力，这是练内功。一是要学习好的写作方法，二是要不断地练笔（其实写文档就是在练笔）。CMM 初始级：项目的实施不可预测。组织缺乏明文的管理办法，软件工作没有稳定的环境，制定了计划又不执行，反应式驱动工作开展。紧急情况下已定的规程丢在一边，急于编码和测试。个别项目的成功依赖于某个有经验的管理人员；个别管理人员能顶住削减过程的压力，但他们离职则全然不同。规定的过程无法克服由于缺乏有效管理带来的不稳定性。能力：不可预测。可重复级：建立了基本的软件过程，可跟踪成本、进度、功能和质量 -基于以往项目经验，制定了过程实施规范，项目管理过程稳定，软件机构可重复以前成功项目中所进行的软件项目工程实践。–如有分包，其质量也能得到控制。–能力：稳定的策划和跟踪。已定义级–完整的软件过程，实现了标准化和文档化 –针对特定项目，可将标准软件过程进行剪裁。– 固定的过程工作小组– 制定和实施了人员培训大纲，保证人员能够胜任岗位知识和技能要求– 管理活动和过程活动稳定，成本、进度、功能和质量可控，软件产品质量具有可追溯性。– 能力：稳定的管理和技术活动 已管理级– 对软件过程（过程模型及过程实例）和生产率和软件产品 质量建立了定量的目标，所有重要的过程活动都是可度量 的。 – 新应用领域的风险可知可控，可在定量的范围内预测过程 和产品的质量趋势，并在偏离时即使予以纠正。– 能力：过程可度量 优化级– 不断的过程改进。可得到软件过程有效性的统计数字，并 用于对新技术的成本 / 效率分析，优化出最佳实践方法。 自知过程的薄弱环节，可预防缺陷的出现。可通过对当前过程的分析，评价对新技术或将出现的变更作出评价。重视探索创新活动，并将成功的创新推广。出现的缺陷得到分析，找出原因，防止再次发生，教训为其它项目吸取。– 能力：过程可优化CMMI的三个模型：CMMI-SVC帮助服务性组织去建立质量服务过程架构使其能够更好的改进服务表现和提高企业的服务收益性。CMMI-ACQ模型帮助组织或企业为他们的客户进行外包、采购、交易或者其他采购产品服务提供了管理架构。CMMI-DEV模型帮助生产服务开发组织整合他们的软件开发和系统工程来改进他们本身的性能和提高过程改进的效率。过程域按类划分：组织级的过程定义、过程焦点、过程性能、创新和部署等（过程管理过程）配置管理。产品与质量保证。度量分析。原因分析与解决方案。决策分析与解决方案（支持过程）项目的监督控制。集成项目管理。项目定量管理。风险管理等（项目管理过程）需求管理与开发。技术解决方案。产品集成。确认。验证（工程过程）软件过程能力企业实施软件过程所能实现预期目标的程度，可用于预测企业的软件过程水平。软件过程行为企业在项目开发中遵循其软件过程所能得到的实际结果。软件过程成熟度软件过程行为可被定义，预测和控制并被持续性提高的程度。主要用来表明不同项目所遵循的软件过程的一致性。软件能力成熟度等级企业的软件开发在由低到高成熟化演进过程中所普遍面临的具有一定成熟度标志特征的平台软件过程静态方面当软件过程仅以某种特定的描述形式存在时，过程质量就表现为静态的一面。此时的过程质量实际上就是软件过程描述本身所具备的属性，它表现为：功能性：该过程描述满足实际需要的程度；易使用性：用户使用该过程描述进行过程实施和运作所需的努力程度，其中包括易理解性和易学习性等子特性；准确性：描述特定类型的软件过程的准确程度，可包含精确性、一致性、完整性、冗余度等子特性；易维护性：用户在改进基于该描述形式的软件过程时所需的努力程度，其中包括易分析性和易修改性等子特性。软件过程动态方面 当软件过程在执行运作时，过程质量就表现为动态的一面。此时的过程质量是以软件过程所表现出的过程运作能力来衡量，其中包括过程运作能否达到所预定的目标、是否保证了软件产品的质量等，可以简称为过程能力。过程制度化：过程文化：人们的习惯和行为受到过程思维和过程管理原则的影响。过程基础设施。CMMIC Capability 能力M Maturity 成熟度M Model 模型I Integration 集成CMMI是过程评估的检查单2过程改进的指导书，行业最佳实践3过程审计的依据CMMI的表达式分为两种Staged—阶段式Continuous—连续式</p><p><strong>在项目实践中应用了哪些RUP的最佳实践**</strong>？用例建模：通过对系统所需功能进行建模，确定系统的需求和范围，并将其转化为可执行的测试用例，以确保系统能够满足用户需求。迭代开发：采用迭代的方式逐步实现系统的功能，每个迭代都需要完成一定的工作量，并且必须被完整测试和验证。构建和发布管理：使用自动化构建和部署工具来管理代码库和版本控制，并确保每个版本的完整性和可部署性。风险管理：识别、分析和管理项目中存在的风险，制定相应的应对策略，以提高项目成功的概率。团队协作：强调团队成员之间的有效沟通和协作，以确保所有人都理解项目目标和进度，并能够共同努力实现这些目标。过程改进：对项目过程进行评估和反思，在项目结束后总结经验教训并制定改进措施，以促进组织的不断发展和提高。<strong>在项目实践中对敏捷过程产生的具有感悟**</strong>？1需求变化是常态敏捷过程强调快速响应客户需求的变化，因此在项目实践中，我们会经常遇到需求的变化。这需要开发团队具备灵活的思维和快速的响应能力，以确保更好地满足客户需求。2团队协作至关重要敏捷过程注重团队协作和自组织，因此在项目实践中，我们必须建立一个高效的团队，并运用各种工具和方法来促进团队沟通和协作。只有这样，才能确保项目的顺利进行。3持续交付有助于降低风险敏捷过程强调持续交付有价值的软件，这可以帮助我们及早发现问题并及时解决。同时，每次迭代都会生成可运行的软件，这有助于客户更好地理解项目进度和软件功能，降低项目风险。4需要不断改进敏捷过程是一种不断改进的过程，以确保我们能够不断学习和提高。在项目实践中，我们需要定期进行团队回顾和反思，总结经验教训并找出改进的空间，以持续提高项目的质量和效率。<strong>在项目实践中采用了什么手段实现过程度量</strong>？代码行数统计：通过统计代码行数来衡量开发人员的工作量和项目进展情况。这种方法比较简单，但是容易被工程师轻易地操纵。功能点分析：通过事先定义好的功能点来度量项目完成情况。这种方法需要在项目启动前进行详细的需求分析，并且需要专业的功能点测量工具和技术支持。成本效益分析：使用成本效益分析工具来计算项目的成本效益比，以判断项目的经济效益是否达到预期。质量评估：通过软件质量评估指标来度量项目的质量。这种方法需要在项目执行过程中对代码、文档、测试等方面进行评估，结果更加客观、实际。测试覆盖率：使用自动化测试工具来度量测试覆盖率，以确保软件能够满足预期的功能和性能要求。<strong>通过度量发现了哪些问题，进行了哪些改进？</strong>项目延迟：如果项目延迟了，可能是因为开发人员无法按时完成任务或者出现了其他问题。通过度量，可以确定哪些部分需要更多的时间和注意力，并采取相应的措施来加快进度。成本超支：过高的成本可能是由于低效率、错误或其他原因引起的。通过度量，可以确定成本超支的根本原因，并采取相应的措施来控制成本。缺陷率过高：缺陷率过高可能会导致项目失败或延迟。通过度量，可以确定缺陷率高的原因，并采取相应的措施来减少缺陷。代码重复率过高：过高的代码重复率可能会导致代码维护困难、效率低下等问题。通过度量，可以确定代码重复率高的原因，并采取相应的措施来减少代码重复。代码质量低：低质量的代码可能会导致许多问题，包括性能问题、安全漏洞等。通过度量，可以确定代码质量低的原因，并采取相应的措施来提高代码质量。开发人员效率低：低效率可能是由于流程不当、缺乏培训或其他原因引起的。通过度量，可以确定效率低的原因，并采取相应的措施来提高效率。<strong>基于CMM的过程改进是目标驱动的过程改进模式</strong>。基于CMM的过程改进步骤如下：（1）确定本机构目前的CMM成熟度级别，明确下一步需要达到的级别：CMM要求一个机构的成熟度级别应当从第2级开始并逐步升级实施，不允许进行成熟度级别的跨越实施。（2）初始化过程改进：应当将过程改进本身作为一个项目来进行管理和策划。过程改进策划的内容包括：需确定详细步骤和活动及所涉及的里程碑、所涉及的关键人物、资源、进度，并确保所有相关人员得到并确认所策划的内容。3）准备并实施过程评价:由于当前所处的级别已经明确，可以直接利用CMM得到当前软件机构的过程评价结果。例如，假如当前级别已被评价为3级，则可根据第2、3级所标明的能力特点、关键过程域、关键实践来表明本机构当前的过程评价结果（4）分析评价结果和制定改进活动计划:根据所希望达到的CMM级别的关键过程域中对目标、执行约定、执行能力、执行活动、测量和分析、验证执行等关键实践的要求，列出各子目标，对每个子目标，详细计划所需增加的活动、资源、度量方法或工具、验证手段等，并依此制定达到每个子目标的具体计划和实施策略。（5）实施改进活动:依照计划实施改进活动，注意应有必要的监控手段。6）确认改进结果1.组织合格的评估师对所进行的改进活动进行评价，以判定是否达到本机构所希望达到的CMM级别。2.对于那些希望其CMM级别获得SEI认可的软件机构而言，所聘请的评估师必须获得SEI颁发的CMM评估师资质，而对那些仅希望通过CMM评价达到自身改进目标的软件机构而言，可在本机构内部组织进行CMM级别的评价，其方式可模仿SEI要求的评价方式，也可用自身特有的方式进行评价，以判断是否达到了所希望的CMM级别。（7）维持和监督改进的结果:努力将机构维持在新的CMM级别上。应当建立有效的监控机制来保持已达到的级别的持续性。对于CMM5级的机构而言，由于这样的监控机制已经制度化，机构只需保持该制度的正常执行，就能确保改进结果的持续性。但对于其他级别的机构而言，应当指定专门人员监督新级别的维持，并赋予足够的权限。（8）重复1到7<strong>通过一个学期的学习，请你谈谈你对软件工程过程这门课的理解，并请提出对这门课的意见与建议。</strong>对软件工程过程的理解。通过一个学期的学习，我认为软件工程过程是一种系统化、规范化的方法，用于管理和开发软件项目。它不仅关注于软件产品本身，更关注于软件开发的整个过程。软件工程过程包括需求分析、设计、编码、测试、维护等多个阶段，并采用了各种工具和技术来提高软件开发效率和质量。在这门课上，我学到了许多软件工程过程的基本概念和实践技巧。例如，软件需求工程、软件设计模式、软件测试方法和过程改进等方面的知识，这些都对我的日后从事软件开发工作有很大的帮助。此外，在这个过程中还学习了如何与团队成员合作，如何有效地沟通和交流，如何协调和管理项目进度和风险等重要技能。对这门课的意见与建议1. 实践与理论结合在学习软件工程过程的时候，我们需要更多地将理论知识应用到实际项目中去。希望课程能够通过更多的案例和实践活动，让我们更深入地了解软件工程过程各个阶段的操作和实践经验。2. 更新内容随着时代的变化和技术的不断更新，软件开发过程也在不断地演变和改进。因此，希望课程也能及时更新课程内容，使学生能够获得最新的知识和技能。3. 更多互动在这门课程中，我们需要和其他同学进行合作、交流和讨论。但是，有时候课堂上的讨论并不充分或者略显被动。因此，希望老师能够提供更多互动的机会，让学生更积极地参与讨论和交流。同时，还可以通过在线平台等方式，在课外时间进一步加强交流和合作。我国软件开发存在的问题 （1）质量意识淡薄，企业从上到下都缺乏正确的产品质量意识，只注重完成软件产品的功能，忽视产品的质量问题。（2）体制不灵活，不健全，导致质量监督不力。由于体制问题造成软件人才不必要的流动，同样是因为体制问题造成实际上企业的软件资产流失。（3）做产品的概念不浓，大多只为短期的经济利益，做短期的项目。（4）形式化的东西太多，为追求评奖或完成项目，报喜不报忧。（5）软件企业的交流少，思想保守。（6）对新技术研究的跟进、投入少。（7）多数项目盲目采用国外技术，没有从自身问题入手，寻找适合产品开发的技术和过程。工具使用项目管理项目管理是指通过规划、组织、监督和控制资源来达成项目目标的过程。在软件工程过程中，项目管理工具通常包括计划、任务分配、进度跟踪、风险管理等功能。以下是一些常用的项目管理工具：Trello：Trello 是一个简单而直观的看板式项目管理工具，可用于团队协作、任务分配、进度追踪、文档共享等。Asana：Asana 是一个全功能的项目管理工具，可用于任务管理、进度跟踪、文件共享、团队讨论等。JIRA：JIRA 是一款流行的跟踪和管理问题的工具，它可用于敏捷开发、版本控制、缺陷管理等。配置管理配置管理是指对软件开发生命周期内的软件产品进行追踪和控制的过程。配置管理工具可以帮助团队管理各个版本的代码和文档，并确保所有成员都使用相同的版本。以下是一些常用的配置管理工具：Git：Git 是目前最流行的版本控制系统之一，它可以跟踪变更、协作以及管理代码。Subversion：Subversion 是一个中心化的版本控制系统，可用于管理文档和代码等各种类型的数据。变更管理变更管理是指对软件开发过程中的需求变更进行有效跟踪和管理的过程。以下是一些常用的变更管理工具：GitHub：GitHub 是一个基于 Git 的代码托管平台，除了提供版本控制功能外，还提供了问题跟踪、协作、自动构建等功能。Bitbucket：Bitbucket 是另一个基于 Git 的代码托管平台，它与 JIRA 集成，可用于敏捷开发和协作。Scrum和XP最佳实践的应用总结：Scrum产品待办列表（Product Backlog） - 创建一个清晰的、有优先级的任务列表，并与团队共享。保持待办事项简单明了、可测量和可分解。冲刺计划（Sprint Planning） - 与团队一起创建一个可执行的计划，以在下一个迭代中完成一组任务集。冲刺回顾（Sprint Review） - 回顾上一个迭代中已经完成的工作，以及未来如何改进和提高。每日站会（Daily Standup） - 每天同步团队进度，让所有人都知道自己正在做什么，并协调解决可能存在的问题。燃尽图（Burndown Chart） - 通过跟踪项目中的工作量，燃尽图可以显示剩余工作量和进度是否满足预期。XP测试驱动开发（TDD） - 在编写代码之前编写单元测试，以确保代码质量和正确性。这将消除很多代码错误。持续集成（Continuous Integration） - 持续整合代码，防止开发人员在开发过程中出现意外错误造成的问题，并确保代码质量。短期迭代（Short Iterations） - 将开发分解为小的、可重复的任务集，以改进开发流程并降低风险。团队编程（Pair Programming） - 两个开发人员一起编写代码，增强协作和知识共享，并提高代码质量。简单设计（Simple Design） - 设计要尽可能简单，易于理解和修改。避免过度设计和不必要的复杂性。</p><p><img src="/../../images/%E8%BD%AF%E4%BB%B6%E8%BF%87%E7%A8%8B%E5%A4%8D%E4%B9%A0/clip_image002.png" alt="img"><img src="/../../images/%E8%BD%AF%E4%BB%B6%E8%BF%87%E7%A8%8B%E5%A4%8D%E4%B9%A0/clip_image004.png" alt="img"><img src="/../../images/%E8%BD%AF%E4%BB%B6%E8%BF%87%E7%A8%8B%E5%A4%8D%E4%B9%A0/clip_image006.png" alt="img"><img src="/../../images/%E8%BD%AF%E4%BB%B6%E8%BF%87%E7%A8%8B%E5%A4%8D%E4%B9%A0/clip_image008.jpg" alt="img"></p><p><img src="/../../images/%E8%BD%AF%E4%BB%B6%E8%BF%87%E7%A8%8B%E5%A4%8D%E4%B9%A0/clip_image010.jpg" alt="img"><img src="/../../images/%E8%BD%AF%E4%BB%B6%E8%BF%87%E7%A8%8B%E5%A4%8D%E4%B9%A0/clip_image012.jpg" alt="img"><img src="/../../images/%E8%BD%AF%E4%BB%B6%E8%BF%87%E7%A8%8B%E5%A4%8D%E4%B9%A0/clip_image014.jpg" alt="img"><img src="/../../images/%E8%BD%AF%E4%BB%B6%E8%BF%87%E7%A8%8B%E5%A4%8D%E4%B9%A0/clip_image016.png" alt="img"></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 读书 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软件过程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java类和对象在内存中的表现形式</title>
      <link href="/post/d7eaf419.html"/>
      <url>/post/d7eaf419.html</url>
      
        <content type="html"><![CDATA[<p>Java内存分配与管理是Java的核心技术之一，不管学习任何一门语言，我们要知其然，知其所以然，本文主要分析下Java中类和对象在内存中的表现形式，方便我们对其有更深了解。一般Java在内存分配时会涉及到这几个区域：栈区（stack）、堆区（heap）、方法区（Method Area）、常量池。我们先对下面几个概念进行深刻了解后，再进行画图分析类和对象在内存中的变化及表现形式。</p><p>栈：存放基本类型的数据和对象的引用变量的数据，但对象本身不存放在栈中，而是存放在堆中（new 出来的对象）</p><p>堆：存放用new产生的对象数据，每个对象包含了一个与之对应的 class 类的信息。</p><p>方法区（又称为静态区）：存放对象中用static定义的静态成员</p><p>常量池：通常用来存放常量数据、静态变量、类的加载信息等</p><h3 id="栈区"><a href="#栈区" class="headerlink" title="栈区"></a>栈区</h3><p>在函数(方法)中定义的一些基本类型的变量或者对象的引用变量都在栈内存中分配。</p><p>当在一段代码块定义一个变量时，Java就在栈中为这个变量分配内存空间，当该变量退出该作用域后，Java会自动释放掉为该变量所分配的内存空间，该内存空间可以立即被另作他用。栈中的数据大小和生命周期是可以确定的，当没有引用指向数据时，这个数据就会消失。</p><p>每个方法（Method）执行时，都会创建一个方法栈区，用于存储局部变量表、操作数栈、动态链接、方法出口信息等</p><p>栈中所存储的变量和引用都是局部的（即：定义在方法体中的变量或者引用），局部变量和引用都在栈中（包括final的局部变量）</p><p>八种基本数据类型（byte、short、int、long、float、double、char、boolean）的局部变量（定义在方法体中的基本数据类型的变量）在栈中存储的是它们对应的值</p><p>每个线程包含一个栈区，栈中只保存基本数据类型的变量和引用数据类型的变量，每个栈中的数据(基本数据类型和对象的引用)都是私有的，其它栈是无法进行访问的。栈分为3个部分：基本类型变量区、执行环境上下文、操作指令区(存放操作指令)。</p><p>栈中还存储局部的对象的引用（定义在方法体中的引用类型的变量），对象的引用并不是对象本身，而是对象在堆中的地址，换句话说，局部的对象的引用所指对象在堆中的地址在存储在了栈中。当然，如果对象的引用没有指向具体的对象，对象的引用则是null</p><p>栈的优势是，存取速度比堆要快，仅次于寄存器，栈数据可以共享。但缺点是，存在栈中的数据大小与生存期必须是确定的，缺乏灵活性。</p><p>栈有一个很重要的特殊性，就是存在栈中的数据可以共享。</p><h3 id="堆区"><a href="#堆区" class="headerlink" title="堆区"></a>堆区</h3><p>堆内存用来存放由new创建的对象和数组。在堆中分配的内存，由Java虚拟机的自动垃圾回收器来管理。</p><p>堆内存是被所有线程共享的一块内存区域，在虚拟机启动时创建。Java堆（Java Heap）唯一目的就是存放对象实例。所有的对象实例及数组都要在<strong>Java堆（Java Heap）</strong>上分配内存空间。</p><p>在堆中产生了一个数组或对象后，在栈中定义一个特殊的变量，让栈中这个变量的取值等于数组或对象在堆内存中的首地址，栈中的这个变量就成了数组或对象的引用变量。引用变量就相当于是为数组或对象起的一个名称，以后就可以在程序中使用栈中的引用变量来访问堆中的数组或对象。引用变量就相当于是为数组或者对象起的一个名称。</p><p>引用变量是普通的变量，定义时在栈中分配，引用变量在程序运行到其作用域之外后被释放。而数组和对象本身在堆中分配，即使程序运行到使用 new 产生数组或者对象的语句所在的代码块之外，数组和对象本身占据的内存不会被释放，数组和对象在没有引用变量指向它的时候，才变为垃圾，不能在被使用，但仍然占据内存空间不放，在随后的一个不确定的时间被垃圾回收器收走（释放掉），这也是Java比较占内存的原因。</p><p>实际上，栈中的变量指向堆内存中的变量，这就是Java中的指针！</p><p>Java的堆是一个运行时数据区,类的对象从中分配空间。对象一般通过new 来创建，例如new Date()，它们不需要程序代码来显式的释放。堆是由垃圾回收来负责的，堆的优势是可以动态地分配内存大小，生存期也不必事先告诉编译器，因为它是在运行时动态分配内存的，Java的垃圾收集器会自动收走这些不再使用的数据。但缺点是，由于要在运行时动态分配内存，存取速度较慢。</p><h3 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h3><p>方法区跟堆一样，又被称为静态区，通常存放常量数据。它存储已被Java虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等,它跟堆一样，被所有的线程共享。</p><h4 id="存储的类信息"><a href="#存储的类信息" class="headerlink" title="存储的类信息"></a>存储的类信息</h4><p>对每个加载的类型（类class、接口interface、枚举enum、注解annotation），JVM必须在方法区中存储以下类型信息：</p><p>这个类型的完整有效名称（全名=包名.类名）</p><p>这个类型直接父类的完整有效名称( java.lang.Object除外，其他类型若没有声明父类，默认父类是Object)</p><p>这个类型的修饰符(public、abstract、final的某个子集)</p><p>这个类型直接接口的一个有序列表</p><p>除此之外还方法区（Method Area）存储类信息还有</p><p>类型的常量池( constant pool)</p><p>域(Field)信息</p><p>方法(Method)信息</p><p>除了常量外的所有静态(static)变量</p><h4 id="存储的常量"><a href="#存储的常量" class="headerlink" title="存储的常量"></a>存储的常量</h4><p>static final修饰的成员变量都存储于 方法区（Method Area）中</p><h4 id="存储的静态变量"><a href="#存储的静态变量" class="headerlink" title="存储的静态变量"></a>存储的静态变量</h4><p>静态变量又称为类变量，类中被static修饰的成员变量都是静态变量（类变量）</p><p>静态变量之所以又称为类变量，是因为静态变量和类关联在一起，随着类的加载而存在于方法区（而不是堆中）</p><p>八种基本数据类型（byte、short、int、long、float、double、char、boolean）的静态变量会在方法区开辟空间，并将对应的值存储在方法方法区，对于引用类型的静态变量如果未用new关键字为引用类型的静态变量分配对象（如：static Object obj;），那么对象的引用obj会存储在方法区中，并为其指定默认值null;若对于引用类型的静态变量如果用new关键字为引用类型的静态变量分配对象（如：static Cat cat = new Cat();）,那么对象的引用cat会存储在方法区中，并且该对象在堆中的地址也会存储在方法区中（注意此时静态变量只存储了对象的堆地址，而对象本身仍在堆内存中）;当然这个过程还涉及到静态变量初始化问题。</p><h4 id="存储的方法（Method）"><a href="#存储的方法（Method）" class="headerlink" title="存储的方法（Method）"></a>存储的方法（Method）</h4><p>程序运行时会加载类编译生成的字节码，这个过程中静态变量（类变量）和静态方法及普通方法对应的字节码加载到方法区。</p><p>方法区中没有实例变量，这是因为，类加载先于对应类对象的产生，而实例变量是和对象关联在一起的，没有对象就不存在实例变量，类加载时没有对象，所以方法区中没有实例变量。</p><p>静态变量（类变量）和静态方法及普通方法在方法区（Method Area）存储方式是有区别的</p><h3 id="常量池"><a href="#常量池" class="headerlink" title="常量池"></a>常量池</h3><p>常量池指的是在编译期被确定，并被保存在已编译的.class文件中的一些数据。</p><p>除了包含代码中所定义的各种基本类型（如int、long等等）和对象型（如String及数组）的常量值(final)还包含一些以文本形式出现的符号引用，比如：类和接口的全限定名；字段的名称和描述符；方法和名称和描述符。</p><p>虚拟机必须为每个被装载的类型维护一个常量池。常量池就是该类型所用到常量的一个有序集和，包括直接常量（string,integer和floating point常量）和对其他类型，字段和方法的符号引用。对于String常量，它的值是在常量池中的。而JVM中的常量池在内存当中是以表的形式存在的，对于String类型，有一张固定长度的CONSTANT_String_info表用来存储文字字符串值，注意：该表只存储文字字符串值，不存储符号引用。说到这里，对常量池中的字符串值的存储位置应该有一个比较明了的理解了。在程序执行的时候,常量池会储存在方法区（Method Area）,而不是堆中。</p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基本数据类型和引用数据类型的区别</title>
      <link href="/post/15e5016d.html"/>
      <url>/post/15e5016d.html</url>
      
        <content type="html"><![CDATA[<h3 id="存储上的区别"><a href="#存储上的区别" class="headerlink" title="存储上的区别"></a>存储上的区别</h3><p>1.基本数据类型是存放在栈中的简单数据段。</p><p>2.引用数据类型是存放在堆内存中的对象，在栈内存中存放的是堆内存中具体内容的引用地址，通过这个地址可以快速查找到对象。</p><h3 id="比较上的区别"><a href="#比较上的区别" class="headerlink" title="比较上的区别"></a>比较上的区别</h3><p>1.基本数据类型的比较是值的比较</p><p>var a = ‘{}’</p><p>var b = ‘{}’</p><p>console.log(a == b) //true</p><p>直接比较值，看起来一样那么他就是一样的。</p><p>2.引用类型的比较是引用的比较</p><p>var a = {}</p><p>var b = {}</p><p>console.log(a == b) //false</p><p>问：看起来明明一样为什么会是false？</p><p>答：因为引用类型比较的是地址，也就是比较两个对象保存在栈区的指向堆内存的地址是否相同，虽然看起来一样，但是他们指向堆内存的地址是不一样的，所以两个对象不相等。</p><h3 id="赋值上的区别"><a href="#赋值上的区别" class="headerlink" title="赋值上的区别"></a>赋值上的区别</h3><p>1.基本数据类型的赋值是简单赋值，如果一个变量向另一个变量赋值基本类型的值，会在变量对象上创建一个新值，然后把这个值复制到为新变量分配的位置上。</p><p>var a = 10</p><p>var b = a</p><p>a++</p><p>console.log(a) //11</p><p>console.log(b) //10</p><p>a在内存中保存的值是10，当使用a的值来初始化b时，b中也保存了10，这两个值是完全独立的，相当于b把a的值复制了一份，所以两个变量的任何操作都不会互相影响。</p><p>2.引用类型的赋值是对象引用</p><p>var a = {}</p><p>var b = a</p><p>a.name = “haha”</p><p>console.log(a.name) //haha</p><p>console.log(b.name) //haha</p><p>b.age = 29</p><p>console.log(a.age) //29</p><p>console.log(b.age) //29</p><p>当一个变量向另一个变量赋值引用类型的值时，同样也会将栈内存中的值复制一份放到新变量分配的空间中，但是引用类型保存在栈内存中的变量是一个地址，这个地址指向的是堆内存中的对象，所以这个变量其实复制了一个地址，两个地址指向同一个对象，改变其中任何一个变量都会互相影响。</p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据类型 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>传统书信中的结束语</title>
      <link href="/post/e7db1469.html"/>
      <url>/post/e7db1469.html</url>
      
        <content type="html"><![CDATA[<p>1.言不尽思，再祈珍重</p><p>【释义】想说的话没能在信里全部表达出来，再次希望你能珍重身体。</p><p>2.投笔伤情，临书惘惘</p><p>【释义】面对所写的书信，心中十分怅惘，表达对对方的思念之情。</p><p>3.渐入严寒，伏惟珍重</p><p>【释义】渐渐地进入寒冷的冬天了，希望（您）多多保重身体。</p><p>4.秋风萧萧，至祈摄卫</p><p>【释义】秋天天气变凉，真挚地提醒你要保重身体。</p><p>5.兹际炎暑，希自珍卫</p><p>【释义】现在正值炎夏酷热之际，希望您对自己的身体予以珍惜爱护。</p><p>6.春寒料峭，善自珍重。</p><p>【释义】天气虽暖还寒，尚望您自己多加保重。</p><p>7.情长纸短，不尽依依。</p><p>【释义】简短的信纸无法写完深长的情意，就不在这纸上尽述了。</p><p>8.天寒露重，望君保重</p><p>【释义】天气非常的寒冷，路上的露水很多，希望你能一路顺风，照顾好自己。</p><p>10.书未尽情，余候面叙</p><p>【释义】用书信难以充分表达情意，等以后我们见面再说。</p><p>11.暂书至此，不复一一</p><p>【释义】暂且先写到这里吧，就不再逐一叙说了。</p>]]></content>
      
      
      <categories>
          
          <category> 生活 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 书信 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>瀑布式开发和敏捷开发区别</title>
      <link href="/post/be383a84.html"/>
      <url>/post/be383a84.html</url>
      
        <content type="html"><![CDATA[<h3 id="瀑布开发"><a href="#瀑布开发" class="headerlink" title="瀑布开发"></a>瀑布开发</h3><p>瀑布模型式是最典型的预见性的方法，严格遵循预先计划的需求、分析、设计、编码、测试的步骤顺序进行。步骤成果作为衡量进度的方法，例如需求规格，设计文档，测试计划和代码审阅等等。</p><p>瀑布式的主要的问题是它的严格分级导致的自由度降低，项目早期即作出承诺导致对后期需求的变化难以调整，代价高昂。瀑布式方法在需求不明并且在项目进行过程中可能变化的情况下基本是不可行的。</p><p>有论文统计，它是造成70%软件开发失败的原因。</p><p>瀑布开发大体分为这几个阶段：需求分析、设计、编码、测试、维护。</p><p>目前来说2B的传统企业，包括ERP，MES，WMS，CRM，OA，IBMS等系统当中可以经常见到他们的影子。现在这种模式仍然流行在一些大的项目或者是外包的一些项目当中。</p><h4 id="瀑布模型作为最典型的预见性方法，其优点主要在于："><a href="#瀑布模型作为最典型的预见性方法，其优点主要在于：" class="headerlink" title="瀑布模型作为最典型的预见性方法，其优点主要在于："></a>瀑布模型作为最典型的预见性方法，其优点主要在于：</h4><p>阶段清晰：从计划到开发最后到上线运行，三个阶段非常清晰。</p><p>时间顺序：每个阶段顺序必须是从上到下，严格按照时间先后进行。</p><p>环环相扣：在每一个阶段都必须有产出物然后才能进入到下一个阶段进行。</p><p>黑盒模式：每个阶段都有各自的角色和分工，各自只关心自己的任务。比如需求阶段开发人员无需关注。</p><h4 id="而其缺点也突出："><a href="#而其缺点也突出：" class="headerlink" title="而其缺点也突出："></a>而其缺点也突出：</h4><p>需求隔离：由于各阶段的人员只能接触到自己工作范围内的东西，所以对客户需求的理解程度高低不等，开发人员更像是定义为流水线上的工人。</p><p>变更代价大：既然叫做瀑布，就意味着不应该走回头路。否则如果出现返工，付出的代价会很大。需求变更，编码人员会很强的抵触情绪。</p><p>束缚创造性：由于强调文档管理，所以管理人员会比较喜欢，但是他束缚了开发人员的创造性。</p><p>周期漫长：整个开发持续的生命周期很长，需求和设计的时间会耗费特别多，有时候会占用三分之一甚至更多时间，这样整个周期就会变长，大都在半年到一年左右的时间，所以更适合需求相对稳定的大项目。</p><h3 id="敏捷软件开发"><a href="#敏捷软件开发" class="headerlink" title="敏捷软件开发"></a>敏捷软件开发</h3><p>敏捷软件开发是基于敏捷宣言定义的价值观和原则的一系列方法和实践的总称。自组织、跨职能团队运用适合他们自身环境的实践进行演进得出解决方案。</p><p>敏捷开发以用户的需求进化为核心，采用迭代、循序渐进的方法进行软件开发。</p><p>在敏捷开发中，软件项目在构建初期被切分成多个子项目，各个子项目的成果都经过测试，具备可视、可集成和可运行使用的特征。换言之，就是把一个大项目分为多个相互联系，但也可独立运行的小项目，并分别完成，在此过程中软件一直处于可使用状态。</p><p>敏捷开发借助互联网浪潮开始流行起来，相比瀑布模式，敏捷无疑更加贴近互联网时代背景下快速发展变化的市场环境以及业务需求。</p><h4 id="简单总结，敏捷开发的优点在于："><a href="#简单总结，敏捷开发的优点在于：" class="headerlink" title="简单总结，敏捷开发的优点在于："></a>简单总结，敏捷开发的优点在于：</h4><p>更快交付价值</p><p>更低的风险</p><p>拥抱变化</p><p>更好的质量</p><p>持续改进</p><p>更高的客户满意度</p><p>更高的团队满意度</p><p>……</p><h4 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h4><p>很难进行准确的资源规划</p><p>很难准确的定义“轻量的“或必要的文档</p><p>很难把握整体产品的一致性</p><p>很难预测有限的终点</p><p>很难有效地进行度量</p><p>…….</p><p>从上文来看，敏捷开发似乎要优于瀑布开发，但本质并非如此。</p><p>两者都有自己适用的范围，而当下这VUCA时代，大部分项目可能都适合用敏捷开发，但仍旧有一部分确定性很强的项目会适合适用瀑布开发。</p>]]></content>
      
      
      <categories>
          
          <category> 读书 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 开发模型 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>工程概论案例分析报告</title>
      <link href="/post/191bfb4f.html"/>
      <url>/post/191bfb4f.html</url>
      
        <content type="html"><![CDATA[<h1 id="案例选题"><a href="#案例选题" class="headerlink" title="案例选题"></a>案例选题</h1><p>案例所属章节：第1章 工程与社会</p><p>案例名称：苹果人脸识别技术Face ID</p><p>案例反映的问题：</p><blockquote><p>随着移动设备的普及和人工智能技术的发展，生物识别技术在身份验证领域的应用越来越广泛，并且成为了一种趋势。苹果公司的人脸识别技术是生物识别技术中的一种，它可以提高身份验证的安全性，避免身份被盗用或冒用。同时，与传统的密码或指纹识别相比，人脸识别技术具有更高的可靠性和不可复制性，因此，越来越多的移动设备采用了生物识别技术来进行身份验证。</p><p>然而，生物识别技术也带来了一些潜在的问题。例如，生物识别技术依赖于个人生物特征数据的采集和存储，如果这些数据被泄露或被黑客攻击，将导致用户的隐私受到威胁。此外，由于生物识别技术基于人工智能算法，可能会存在算法偏差和错误的情况，例如，无法识别面部特征受到损伤的用户。</p><p>因此，在使用生物识别技术时，需要注意保护用户的隐私和数据安全，并建立有效的安全机制来应对潜在的风险和问题。同时，还需要持续优化算法和提高生物识别技术的准确性和稳定性。</p></blockquote><p>案例来源：苹果公司官方网站</p><h1 id="案例内容"><a href="#案例内容" class="headerlink" title="案例内容"></a>案例内容</h1><p>苹果公司的人脸识别技术在当时的手机市场上引起了巨大的轰动，它使得用户不再需要使用传统的密码或指纹解锁，而是通过面部识别进行快速和方便的身份验证。在这个案例中，我们将深入探讨苹果公司的人脸识别技术发展过程，以及它在手机市场中所带来的影响和改变。</p><h2 id="苹果人脸识别技术Face-ID前世今生"><a href="#苹果人脸识别技术Face-ID前世今生" class="headerlink" title="苹果人脸识别技术Face ID前世今生"></a>苹果人脸识别技术Face ID前世今生</h2><p>起：苹果公司的人脸识别技术起源于2013年，当时苹果公司收购了一家以色列公司PrimeSense，这家公司专注于开发3D传感器技术。苹果公司随后利用这项技术开发了Face ID。2017年，苹果公司推出了搭载Face ID技术的iPhone X，引起了广泛关注。</p><p>承：Face ID是一种3D人脸识别技术，它通过对用户面部进行3D扫描和建模来实现人脸识别。这种技术比传统的2D人脸识别更加安全，因为它可以检测用户是否真的在使用手机，而不是使用一张照片或者面具来欺骗系统。同时，Face ID的误识率仅为50万分之一，比Touch ID指纹识别技术更加安全。</p><p>转：Face ID不仅可以用于解锁手机，还可以用于在购物、银行、保险和医疗等领域进行身份验证。这使得用户可以方便地使用手机进行在线支付，或者在医院或银行进行身份验证。同时，苹果公司不断对Face ID技术进行改进，使得它的识别速度和准确性得到了提高。</p><p>合：随着苹果公司对Face ID技术的不断改进，Face ID在iPhone、iPad和Mac等设备上得到了广泛应用。同时，苹果公司还将Face ID技术授权给其他公司使用，使得人脸识别技术在全球范围内得到普及。</p><h2 id="苹果人脸识别技术Face-ID实现原理"><a href="#苹果人脸识别技术Face-ID实现原理" class="headerlink" title="苹果人脸识别技术Face ID实现原理"></a>苹果人脸识别技术Face ID实现原理</h2><p>苹果的人脸识别技术Face ID的实现原理基于TrueDepth相机系统，使用了多项技术和组件，包括以下几个方面：</p><p>3D感测器：TrueDepth相机系统采用了3D感测器，可以感知用户的面部轮廓和深度信息。该3D感测器由红外摄像头、点阵投影器和红外光源组成。</p><p>红外摄像头：TrueDepth相机系统中的红外摄像头可以捕捉用户的面部图像，用于识别和匹配。</p><p>点阵投影器：TrueDepth相机系统中的点阵投影器会向用户的面部投射30,000多个红外光点，并记录每个光点的反射情况，以创建用户的3D面部模型。</p><p>红外光源：TrueDepth相机系统中的红外光源可以在低光环境下进行面部扫描，并检测出不同表面的深度差异，以构建3D面部模型。</p><p>图1 iPhone X上的传感器</p><p>Face ID的工作流程如下：</p><p>当用户将设备放在面前时，TrueDepth相机系统开始工作，向用户的面部投射30,000多个红外光点。</p><p>红外摄像头捕捉用户的面部图像，并将其发送到设备上的Secure Enclave中进行处理。</p><p>Secure Enclave使用存储在其中的神经网络模型，对面部图像进行处理和分析，以确定用户的面部特征。</p><p>Secure Enclave将面部特征与预先存储在设备上的面部特征进行比较和匹配，以验证用户的身份。</p><p>如果面部特征匹配成功，则设备将解锁，否则将要求用户再次尝试或使用其他解锁方法。</p><p>图2 苹果采用FaceID技术</p><p>Face ID的实现原理可以确保用户的面部特征得到安全保护，因为所有的面部图像都被处理和存储在设备上，不会被发送到服务器或其他地方进行验证。同时，Face ID的高精度和低误识率使其成为一种高度安全和方便的身份认证方式。</p><h2 id="苹果人脸识别技术影响与成就"><a href="#苹果人脸识别技术影响与成就" class="headerlink" title="苹果人脸识别技术影响与成就"></a>苹果人脸识别技术影响与成就</h2><p>1. 提供更加高级的身份验证：苹果人脸识别技术Face ID通过3D传感器对用户面部进行扫描，从而实现高度准确的身份验证。相比传统的身份验证方式，如密码和指纹识别，Face ID更加安全、方便和快捷。</p><p>2. 提高了设备安全性：通过Face ID，苹果能够提供更加安全的设备解锁和支付验证。这种技术能够检测到使用面具、假发等伪装，从而防止黑客利用假面具等方式进行设备解锁和支付。</p><p>3. 改善了用户体验：Face ID相比指纹识别更加方便快捷，并且可以在低光环境和弱光条件下使用。这种技术让用户能够更加便捷地使用设备，同时提高了用户体验。</p><p>4. 面部数据隐私：Face ID将用户的面部数据转换成一个数字码，这种技术保护了用户的面部数据隐私。这个数字码只存储在设备本地，不会上传到云端或者其他第三方平台。</p><h1 id="案例分析报告"><a href="#案例分析报告" class="headerlink" title="案例分析报告"></a>案例分析报告</h1><h2 id="苹果人脸识别技术Face-ID主要技术"><a href="#苹果人脸识别技术Face-ID主要技术" class="headerlink" title="苹果人脸识别技术Face ID主要技术"></a>苹果人脸识别技术Face ID主要技术</h2><p>本案例涉及的理论和工具包括深度学习、计算机视觉、人工智能、图像处理等领域的基础理论和相关工具，如TensorFlow、OpenCV、Keras等开源框架和算法库。</p><p>苹果人脸识别技术Face ID主要使用的技术和算法：</p><p>深度相机技术：苹果公司采用了深度相机技术来进行人脸识别，这种技术可以通过红外线传感器来感知物体的深度，从而为人脸识别提供更加精确的深度信息。苹果采用的深度相机技术可以在低光环境下进行准确的人脸识别。</p><p>3D建模技术：苹果公司的人脸识别技术使用了3D建模技术，可以为人脸提供更加准确的三维模型。这种技术可以在光线不足或面部遮挡的情况下进行人脸识别。采用3D建模技术可以对人脸进行更加准确的建模，可以大大提高人脸识别的准确率。</p><p>面部识别技术：苹果公司的人脸识别技术可以通过检测面部特征来进行人脸识别。这种技术可以通过面部识别进行设备解锁，也可以用于人脸支付等场景。在人脸识别中，面部识别技术是非常关键的一环。</p><p>机器学习技术：苹果公司的人脸识别技术使用了机器学习技术，可以根据用户使用设备的情况来不断优化人脸识别算法。这种技术可以提高人脸识别的准确率和速度。采用机器学习技术可以不断优化算法，提高人脸识别的精度和速度。</p><p>隐私保护技术：苹果公司非常重视用户的隐私保护，在人脸识别技术方面也不例外。苹果公司的人脸识别技术在进行人脸识别时不会上传用户的面部信息，而是将面部信息存储在用户的设备上。这种隐私保护技术可以有效地保护用户的隐私，避免用户的面部信息被不当使用。</p><p>深度神经网络：苹果采用了深度神经网络来进行人脸识别。深度神经网络可以对输入图像进行多次卷积和池化操作，从而提取出更加丰富的特征信息，进而进行人脸识别。深度神经网络在训练时可以自动学习到人脸的特征，提高了人脸识别的准确率。</p><p>卷积神经网络：卷积神经网络是一种特殊的深度神经网络，可以有效地处理图像数据。苹果在人脸识别技术中使用了卷积神经网络，从而可以提取出人脸的特征，进而进行人脸识别。卷积神经网络具有计算效率高、准确率高等优点，在人脸识别中具有很好的应用前景。</p><p>神经网络嵌入（Neural Network Embedding）：神经网络嵌入是一种将高维数据映射到低维空间的技术，可以将人脸图像映射到低维空间中，从而实现人脸识别。苹果采用了神经网络嵌入技术，将人脸图像映射到128维空间中，并通过计算欧几里得距离来进行人脸匹配。</p><p>支持向量机（SVM）：支持向量机是一种常用的分类算法，可以将数据进行分类。在苹果的人脸识别技术中，支持向量机可以用于人脸特征的分类和判别。支持向量机具有较高的准确率和较好的泛化能力，在人脸识别中也具有一定的应用价值。</p><p>人脸对齐算法：人脸对齐算法可以将不同姿态下的人脸图像进行对齐，从而提高人脸识别的准确率。在苹果的人脸识别技术中，采用了人脸对齐算法，可以将不同角度、不同表情的人脸图像进行对齐，从而提高人脸识别的准确率。</p><p>图3 人脸识别</p><h2 id="苹果人脸识别技术的分析框架"><a href="#苹果人脸识别技术的分析框架" class="headerlink" title="苹果人脸识别技术的分析框架"></a>苹果人脸识别技术的分析框架</h2><p>本文采用SWOT分析框架，从内部和外部环境两个方面对苹果的人脸识别技术进行分析，以明确其优势、劣势、机会和威胁，并提出相关建议。</p><p>SWOT分析：</p><p>优势（Strengths）</p><p>a. 技术领先：苹果的人脸识别技术采用深度学习和计算机视觉等先进技术，实现快速、准确的面部识别，远远领先于其他同类产品。</p><p>b. 用户体验好：人脸识别技术可以实现快速解锁设备、支付等功能，大大提高了用户体验。</p><p>c. 安全性高：苹果的人脸识别技术采用了多种技术保障，如深度学习算法、硬件安全等，可以防止诈骗和恶意攻击，保障用户的安全。</p><p>劣势（Weaknesses）</p><p>a. 需要高性能硬件支持：苹果的人脸识别技术需要高性能的处理器和相机，因此在低端设备上可能无法实现。</p><p>b. 隐私问题：人脸识别技术涉及到用户的面部信息，一旦泄露会对用户的隐私带来风险，因此需要采取一些措施来保障用户的隐私。</p><p>机会（Opportunities）</p><p>a. 市场需求：用户对于快速、便捷、安全的身份验证需求日益增加，人脸识别技术在智能手机、支付、门禁等领域都有广泛的应用前景。</p><p>b. 技术进步：随着深度学习、计算机视觉等技术的不断发展，人脸识别技术将变得更加成熟、准确、稳定。</p><p>威胁（Threats）</p><p>a. 安全威胁：人脸识别技术需要大量的人脸图像和数据进行训练和识别，这些数据可能被黑客和恶意用户窃取，从而造成安全威胁。</p><p>b. 硬件厂商威胁：随着人脸识别技术的普及和应用，硬件厂商也在加速开发和推广相关硬件产品，这可能对苹果的市场占有率和竞争力带来一定的威胁。</p><p>c. 技术更新威胁：随着技术的不断更新和进步，人脸识别技术也可能被其他更加先进的技术所取代，从而对苹果的市场地位带来威胁。</p><p>建议：</p><p>基于上述SWOT分析，我提出以下建议：</p><p>1. 继续加强技术研发和创新，保持技术领先优势，增加硬件兼容性，提高对不同性能设备的支持。</p><p>2. 加强隐私保护措施，增强用户隐私安全保护，加强人脸数据的存储和传输加密等技术措施。</p><p>3. 加强与其他厂商的合作，例如与芯片厂商合作，加强芯片的设计和优化，提高硬件性能和适应性，降低成本。</p><p>4. 加强人工智能的投入和应用，提高算法的稳定性和准确性，进一步提升人脸识别技术的效率和性能。</p><p>结论：</p><p>苹果的人脸识别技术在技术领先、用户体验好、安全性高等方面具有优势，但也存在需要高性能硬件支持和隐私问题等劣势，未来应该加强技术创新和市场推广，同时加强隐私保护和与其他厂商的合作，提高算法的稳定性和准确性，进一步提升人脸识别技术的效率和性能，以保持市场竞争优势和稳定发展。</p><h2 id="人脸识别技术发展趋势"><a href="#人脸识别技术发展趋势" class="headerlink" title="人脸识别技术发展趋势"></a>人脸识别技术发展趋势</h2><p>人脸识别技术在实际应用当中不断成熟，其市场的需求不断增加，人脸识别的应用场景也在不断地被挖掘。当前的人脸识别系统主要包括四个组成部分：人脸图像采集及检测、人脸图像预处理、人脸图像特征提取以及匹配与识别。随着未来数据的增长，在人脸数据匹配方面将面临着更大的挑战。</p><p>大数据快速发展背景下，人脸识别技术必须有所创新。目前，已经出现了为公安大数据打造的云计算人脸识别技术，通过将人脸特征散布到多台电脑进行计算，获取更强的计算能力，同时基于云架构设计，实施混合多算法，提高大数据库容量下人脸图像的识别和对比特性。同时，由于部分时候设备或目标距离较远，获得的人脸图像质量较低，在此情况下人脸识别准确率会受到明显影响，需要利用人脸图像重建技术组建高质量图像，从而辅助提高人脸识别准确率，云计算为人脸图像重建也搭建出更便捷的交流沟通平台。</p><h1 id="苹果人脸识别FaceID技术的利与弊"><a href="#苹果人脸识别FaceID技术的利与弊" class="headerlink" title="苹果人脸识别FaceID技术的利与弊"></a>苹果人脸识别FaceID技术的利与弊</h1><h2 id="利"><a href="#利" class="headerlink" title="利"></a>利</h2><p>（1）提高信息安全性</p><p>FaceID技术采用三维建模和人工智能算法识别用户的面部特征，相较于传统的指纹识别技术更加安全可靠。指纹识别技术容易受到指纹模板的盗取或模拟指纹的攻击，而FaceID技术则可以更好地识别和防范这些攻击。同时，FaceID技术也可以防止其他人通过观察用户输入密码的方式来窃取密码，提高了用户的信息安全性。</p><p>（2）提高用户的便利性</p><p>相较于指纹识别技术，FaceID技术更加便利和快捷，无需用户将手指放在指纹传感器上。用户只需要将设备对准面部即可完成解锁、支付和认证等操作，这在某些场合下可以提高用户的便利性和使用体验。</p><p>图4 Face ID工作器件</p><p>（3）增加产品的竞争力</p><p>FaceID技术的推出，增加了苹果公司产品的竞争力。在信息安全日益重要的背景下，FaceID技术可以提高用户的信息安全性，增加了产品的附加值和吸引力。同时，FaceID技术也可以提高用户的使用体验和便利性，提高了产品的市场竞争力。</p><h2 id="弊"><a href="#弊" class="headerlink" title="弊"></a>弊</h2><p>（1）面部数据安全性问题</p><p>FaceID技术需要采集和存储用户的面部数据，这可能带来一定的面部数据安全性问题。如果FaceID技术的面部数据被黑客攻击或泄露，用户的面部数据可能被窃取，导致隐私泄露和安全问题。虽然苹果公司已经采取了一系列措施来保护用户的面部数据，如使用安全的芯片和数据加密技术等，但仍需要进一步加强面部数据的安全性保护，以防止数据被攻击者窃取或滥用。</p><p>（2）对一些人的识别率不高</p><p>FaceID技术对于一些人的识别率不高，如婴儿、小孩、老年人、面部残疾人士、戴口罩或口音重的人等。这可能导致这些人无法使用该技术或者在使用过程中出现一定的困难。虽然苹果公司已经采取了一些措施来改进这一问题，如提高算法的精度和可靠性等，但仍需要进一步改进和优化算法，以提高面部识别技术的普适性和适用性。</p><p>（3）可能增加对隐私的侵犯</p><p>FaceID技术需要采集和存储用户的面部数据，这可能增加对用户隐私的侵犯。如果面部数据被滥用或泄露，可能会对用户的隐私造成不可逆的损害。同时，FaceID技术可能被用于监控和跟踪用户的活动，这可能引发一些隐私问题和担忧。为了避免这种情况，需要加强面部数据的安全性保护，建立相应的隐私保护机制和法律法规，以确保用户的隐私得到有效保护。</p><h1 id="社会利益和风险"><a href="#社会利益和风险" class="headerlink" title="社会利益和风险"></a>社会利益和风险</h1><p>苹果人脸识别FaceID技术的推出，既带来了社会利益，也带来了一定的社会风险。</p><h2 id="社会利益"><a href="#社会利益" class="headerlink" title="社会利益"></a>社会利益</h2><p>（1）提高信息安全性</p><p>FaceID技术可以提高用户的信息安全性，防止密码泄露和身份盗窃等问题，为用户带来了实实在在的利益。</p><p>（2）增强用户的使用体验和便利性</p><p>相较于传统的指纹识别技术，FaceID技术更加便利和快捷，提高了用户的使用体验和便利性，为用户带来了更好的服务和体验。</p><p>图5 Face ID提供便利</p><p>（3）推动技术发展和创新</p><p>FaceID技术的推出，推动了人脸识别技术的发展和创新，为科技进步和产业发展做出了贡献。</p><h2 id="社会风险"><a href="#社会风险" class="headerlink" title="社会风险"></a>社会风险</h2><p>（1）隐私泄露和滥用问题</p><p>FaceID技术需要采集和存储用户的面部数据，如果这些数据被滥用或泄露，可能会对用户的隐私造成不可逆的损害。这可能会导致个人的隐私被侵犯，造成一定的社会风险。</p><p>（2）对一些人的不适用性</p><p>FaceID技术对一些人的识别率不高，如婴儿、小孩、老年人、面部残疾人士、戴口罩或口音重的人等。这可能导致这些人无法使用该技术或者在使用过程中出现一定的困难。</p><p>（3）技术滥用和歧视问题</p><p>FaceID技术可能被用于不良用途，如犯罪追踪、民族歧视等。这可能会对社会带来一定的风险和危害，需要加强相关的监管和管理，避免技术被滥用和歧视。</p><p>（4）社会心理问题</p><p>FaceID技术可能会对社会心理产生一定的影响，引发一些社会心理问题，如对隐私的担忧、对技术的依赖等。这需要加强公共教育和宣传，提高社会的科技素养和技术安全意识。</p><p>总的来说，苹果人脸识别FaceID技术的推出，既带来了一定的社会利益，也带来了一定的社会风险。需要加强技术研发和优化，加强隐私保护和安全性保障，建立相应的法律法规和监管机制，以确保FaceID技术的正常运行和社会安全稳定。同时，需要提高社会的科技素养和技术安全意识，加强公共教育和宣传，推动科技进步和人类文明的发展。</p><h1 id="数据安全和隐私隐患"><a href="#数据安全和隐私隐患" class="headerlink" title="数据安全和隐私隐患"></a>数据安全和隐私隐患</h1><p>数据安全是指保护数据不被非法获取、使用、披露、破坏和篡改的一系列措施和技术。数据安全对于现代社会来说越来越重要，因为我们的生活越来越依赖于数字技术和互联网，这些技术和网络都需要处理大量的个人和敏感信息。</p><p>为了保护个人信息和数据安全，中国政府制定了《数据安全法》。该法规定了数据安全的基本原则和管理要求，加强了个人信息保护和网络安全的管理，明确了数据安全的监督和执法机构。</p><p>《数据安全法》的主要内容包括：</p><ol><li>数据安全的基本原则：包括合法性、正当性、必要性、明确性、安全性等原则。</li></ol><p>2. 数据安全的管理要求：包括数据收集、存储、使用、传输、处理、销毁等方面的要求。</p><p>3. 个人信息保护：规定了个人信息的范围、收集和使用的要求，以及个人信息泄露的惩罚措施。</p><p>4. 网络安全管理：规定了网络安全的管理要求，包括网络安全保护、信息安全管理、网络安全事件应急等方面。</p><p>5. 数据安全评估和安全事件的处置要求：规定了数据安全评估的要求和安全事件的处置程序。</p><p>6. 数据安全监督和执法机构：明确了数据安全监督和执法机构的职责和权力。</p><p>通过《数据安全法》的实施，可以有效地保护个人信息和数据安全，维护国家安全和社会稳定。同时，个人也应该加强对自己个人信息的保护意识，不泄露个人信息，避免个人信息被滥用。</p><p>苹果人脸识别技术FaceID是一项复杂的工程问题，它通过使用TrueDepth摄像头和红外传感器来捕捉用户的面部图像，并使用高度复杂的算法来识别用户。虽然这种技术被广泛认为是安全和可靠的，但它仍然存在一些安全和隐私隐患。</p><h2 id="安全隐患"><a href="#安全隐患" class="headerlink" title="安全隐患"></a>安全隐患</h2><p>1. 生物识别攻击</p><p>生物识别攻击是指攻击者使用虚拟面具或3D打印的面部模型来欺骗FaceID系统，从而获得未经授权的访问权限。这种攻击需要攻击者有受害者的面部数据，但在公共场所，攻击者可能会通过拍照或其他方式获取这些数据。生物识别攻击可能会导致用户的隐私受到侵犯或数据被泄露。</p><p>2. 活体检测绕过</p><p>FaceID的活体检测功能用于检测正在注册的面部是否是真实的人脸而非照片或虚拟面具。然而，攻击者可以使用一些技巧来绕过这种检测。例如，他们可以使用特殊的眼镜或面具来欺骗系统，并通过识别这些设备来绕过活体检测。这种攻击可能会导致用户的隐私受到侵犯或数据被泄露。</p><p>3. 面部数据泄露</p><p>FaceID需要在设备上存储用户面部数据以进行识别，这些数据可能会被黑客窃取或被不当使用。如果攻击者能够获取用户面部数据，他们可以使用这些数据来欺骗FaceID系统，从而获取未经授权的访问权限。此外，如果面部数据被滥用，用户的隐私可能会受到侵犯。</p><h2 id="隐私隐患"><a href="#隐私隐患" class="headerlink" title="隐私隐患"></a>隐私隐患</h2><p>1. 设备上的面部数据存储</p><p>FaceID需要在设备上存储用户面部数据以进行识别，这意味着用户的面部数据存储在设备上，可能会受到黑客攻击或被不当使用。此外，用户可能担心他们的面部数据被滥用或共享给第三方。</p><p>图6 将面部信息保存到手机中</p><p>2. 面部数据传输</p><p>尽管苹果声称FaceID数据只存储在设备上，并且不会与任何外部服务器共享，但用户仍然需要在使用FaceID时放弃一些隐私权。例如，用户必须在设备上启用TrueDepth摄像头和红外传感器，这些设备可能会收集用户的面部数据和其他个人信息。</p><p>3. 面部识别追踪</p><p>FaceID可以记录用户的面部特征和使用方式，这可能会对用户的隐私产生影响。例如，FaceID可以记录用户何时使用设备以及使用设备的情况。这些数据可能会被苹果和第三方用于广告定位和用户追踪等目的。</p><h2 id="罪与罚"><a href="#罪与罚" class="headerlink" title="罪与罚"></a>罪与罚</h2><p>根据《中华人民共和国刑法》第二百五十三条规定，盗窃、侵占、非法出售、非法提供、非法获取、非法使用或者非法加工个人信息，情节严重的，处三年以下有期徒刑或者拘役，并处或者单处罚金；情节特别严重的，处三年以上七年以下有期徒刑，并处罚金。</p><p>根据《民法典》第111条规定：“自然人的个人信息受法律保护。任何组织或者个人需要获取他人个人信息的，应当依法取得并确保信息安全，不得非法收集、使用、加工、传输他人个人信息，不得非法买卖、提供或者公开他人个人信息。”</p><p>根据《民法典》第1038条规定：“信息处理者不得泄露或者篡改其收集、存储的个人信息；未经自然人同意，不得向他人非法提供其个人信息，但是经过加工无法识别特定个人且不能复原的除外。”</p><p>根据《网络安全法》第42条规定：“未经被收集者同意，不得向他人提供个人信息。但是，经过处理无法识别特定个人且不能复原的除外。”</p><p>根据《网络安全法》第44条规定：“任何个人和组织不得窃取或者以其他非法方法获取个人信息，不得非法出售或者非法向他人提供个人信息。”</p><p>根据《个人信息保护法》第10条规定：“任何组织、个人不得非法收集、使用、加工、传输他人个人信息，不得非法买卖、提供或者公开他人个人信息；不得从事危害国家安全、公共利益的个人信息处理活动。”</p><p>根据《消费者权益保护法》第29条规定：“经营者及其工作人员对收集的消费者个人信息必须严格保密，不得泄露、出售或者非法向他人提供。”</p><h2 id="缓解措施"><a href="#缓解措施" class="headerlink" title="缓解措施"></a>缓解措施</h2><p>1. 增强生物识别攻击防护</p><p>为了防止生物识别攻击，FaceID可以采用更高级的技术来检测虚拟面具和3D打印的面部模型。例如，FaceID可以使用深度学习算法来检测面部的深度和纹理，从而更有效地识别真实的人脸。此外，苹果可以通过更新软件来维护FaceID的安全性，以解决新的生物识别攻击。</p><p>2. 加强活体检测功能</p><p>为了防止活体检测被绕过，苹果可以通过更新软件来加强FaceID的活体检测功能。例如，他们可以添加更多的生物识别技术，如人脸表情、眨眼和头部移动等，以确保正在进行识别的面部是真实的人脸。</p><p>3. 提高面部数据的安全性</p><p>为了保护用户的面部数据，苹果可以采取一些措施来提高面部数据的安全性。例如，他们可以使用端到端加密来保护面部数据的传输，以及使用可信的硬件和软件来保护面部数据的存储。此外，苹果可以在设备中添加一些安全机制，如密码保护和双因素认证，以确保只有授权用户才能访问FaceID。</p><p>4. 加强用户隐私保护</p><p>为了保护用户的隐私，苹果可以采取一些措施来加强用户隐私保护。例如，他们可以提供更多的隐私选项，如关闭FaceID功能，以及在设备上提供更多的隐私控制选项，如禁用TrueDepth摄像头和红外传感器。</p><h2 id="案例分析"><a href="#案例分析" class="headerlink" title="案例分析"></a>案例分析</h2><p>2017年，一名越南安全公司的研究员声称他们利用一个3D打印的面具和一些化妆品，成功欺骗了FaceID，解锁了一部iPhone X1。这引发了人们对FaceID是否能够抵御高仿真的假脸攻击的担忧，以及对苹果公司是否夸大了FaceID的安全性的质疑。</p><p>2018年，一名美国律师发现他的妻子可以用FaceID解锁他的iPhone X，尽管他们没有任何血缘关系，也没有相似的面部特征2。这引发了人们对FaceID是否能够区分不同的个体差异的疑问，以及对苹果公司是否充分测试了FaceID在不同人群中的表现的质疑。</p><p>2019年，一名美国女子发现她在Facebook上购买的一部二手iPhone XR，无法重置FaceID，因为原来的主人没有删除他的面部数据3。这引发了人们对FaceID是否能够保护用户的数据隐私的担忧，以及对苹果公司是否应该提供更多的教育和指导信息的建议。</p><p>以上案例都反映了苹果公司在开发和推广FaceID时可能存在的数据安全和隐私隐患，主要包括以下几个方面：</p><p>1. FaceID是否能够防止被高仿真的假脸或其他物体欺骗，提高其抗攻击能力？</p><p>2. FaceID是否能够识别不同个体之间的微小差异，降低其误识别率和被冒用的风险？</p><p>3. FaceID是否能够保证用户的面部数据只在设备中存储和使用，不被泄露或滥用？</p><p>4. FaceID是否能够提供清晰和易操作的设置选项，让用户可以自由地开启或关闭FaceID，或者重置或删除自己的面部数据？</p><p>要解决这些问题，可能需要苹果公司在技术、法律、教育等方面做出更多努力。例如：</p><p>1. 在技术方面，苹果公司可以继续优化FaceID的算法和硬件，提高其识别精度和安全性，同时也要注意检测和修复可能存在的漏洞或缺陷。</p><p>2. 在法律方面，苹果公司可以遵守相关国家和地区对于人脸识别技术的法规和标准，明确其对于用户面部数据的收集、存储、使用和共享等方面的责任和义务，并在用户协议中进行充分披露。</p><p>3. 在教育方面，苹果公司可以加强对用户和开发者的培训和指导，让他们了解FaceID的工作原理、优点和缺点、使用方法和注意事项等，并提供有效的反馈渠道和客服支持。</p><h1 id="职业道德和规范及可能产生的伦理问题"><a href="#职业道德和规范及可能产生的伦理问题" class="headerlink" title="职业道德和规范及可能产生的伦理问题"></a>职业道德和规范及可能产生的伦理问题</h1><h2 id="职业道德和规范"><a href="#职业道德和规范" class="headerlink" title="职业道德和规范"></a>职业道德和规范</h2><p>1.尊重隐私和安全</p><p>FaceID技术涉及到用户隐私和安全问题，苹果公司需要确保其技术能够保护用户的个人信息和数据安全。在收集、存储和处理用户的面部数据时，苹果公司需要遵守相关的隐私政策和安全标准，保证用户的隐私和安全不会受到侵犯。</p><p>2.透明公开</p><p>苹果公司需要确保其FaceID技术的运作过程透明、公开，向用户提供详细的使用说明和数据收集政策。同时，苹果公司还需要确保用户能够轻松访问和管理他们的个人数据，并允许用户随时撤销使用FaceID的权限。</p><p>3.尊重多样性和包容性</p><p>FaceID技术需要考虑到用户的多样性和包容性，包括种族、性别、年龄、文化背景等方面。苹果公司需要确保其技术对不同用户的面部特征都能够进行准确识别，避免出现歧视等问题。</p><p>4.遵守法律法规</p><p>苹果公司需要遵守当地和国际法律法规，确保其FaceID技术符合相关的法律要求和标准。如果出现法律问题，苹果公司需要积极配合相关部门进行调查和解决。</p><h2 id="可能产生的伦理问题"><a href="#可能产生的伦理问题" class="headerlink" title="可能产生的伦理问题"></a>可能产生的伦理问题</h2><p>1.隐私和安全问题</p><p>FaceID技术需要收集、存储和处理用户的面部数据，这可能会对用户的隐私和安全造成威胁。如果这些数据被黑客攻击或者不当使用，将会对用户的个人信息造成损害。</p><p>2.歧视和偏见问题</p><p>FaceID技术需要在识别面部特征时考虑到多样性和包容性，但是如果技术本身存在歧视和偏见，就会对特定群体造成不公平待遇。例如，如果人脸识别技术不能准确识别某些人种或者性别的面部特征，就可能对这些人造成不公正的待遇。</p><p>3.误判和误识别问题</p><p>FaceID技术的准确性和可靠性是一个重要的问题。如果技术本身存在误判和误识别的问题，就可能对用户的生活和工作造成不良影响。例如，如果人脸识别技术误认为某个人是罪犯或者恐怖分子，就可能引发不必要的调查和麻烦。</p><p>4.监控和跟踪问题</p><p>FaceID技术可以用于监控和跟踪用户的行为和活动，这可能会对用户的自由和隐私造成威胁。如果技术被滥用，就可能导致对个人自由和权利的侵犯。</p><h2 id="案例分析-1"><a href="#案例分析-1" class="headerlink" title="案例分析"></a>案例分析</h2><p>2017年，一名中国女性发现她的同事可以用FaceID解锁她的iPhone X，她怀疑苹果公司的人脸识别技术有缺陷，无法区分不同的亚洲面孔1。这引发了人们对FaceID的准确性和安全性的质疑，以及对苹果公司是否尊重不同种族和文化差异的人脸特征的担忧。</p><p>2018年，一名美国男子告诉媒体，他的10岁儿子可以用FaceID解锁他的iPhone X，他认为这是一种安全漏洞，可能导致未经授权的访问和隐私泄露2。这引发了人们对FaceID是否能够有效区分亲属和陌生人的人脸的疑问，以及对苹果公司是否充分考虑了家庭共享设备的场景的质疑。</p><p>2019年，一名美国女子发现她的前男友可以用FaceID解锁她的iPhone XR，她怀疑他在她睡觉时用她的脸注册了FaceID，从而窃取了她的个人信息和社交账号3。这引发了人们对FaceID是否容易被欺骗和滥用的担忧，以及对苹果公司是否应该提供更多的保护措施和提示信息的建议。</p><p>以上案例都反映了苹果公司在开发和推广FaceID时可能存在的职业道德和伦理问题，主要包括以下几个方面：</p><p>1 FaceID是否能够保证高度的准确性和可靠性，避免误识别或被欺骗的风险？</p><p>2. FaceID是否能够尊重用户的隐私权和自主权，防止用户的人脸数据被非法获取或滥用？</p><p>3. FaceID是否能够考虑不同用户的需求和场景，提供适当的选项和提示信息？</p><p>4. FaceID是否能够遵循公平和多样性的原则，不歧视或偏见任何种族、性别、年龄或其他特征？</p><p>要解决这些问题，可能需要苹果公司在技术、法律、道德等方面做出更多努力。例如：</p><p>1. 在技术方面，苹果公司可以不断改进FaceID的算法和硬件，提高其识别率和安全性，同时也要注意测试其在不同环境和条件下的表现。</p><p>2. 在法律方面，苹果公司可以遵守相关国家和地区对于人脸识别技术的法规和标准，明确其对于用户人脸数据的收集、存储、使用和共享等方面的责任和义务，并在用户协议中进行充分披露。</p><p>3. 在道德方面，苹果公司可以倡导负责任的创新文化，尊重用户的选择和意愿。</p><h1 id="FaceID产生的知识产权法律问题"><a href="#FaceID产生的知识产权法律问题" class="headerlink" title="FaceID产生的知识产权法律问题"></a>FaceID产生的知识产权法律问题</h1><h2 id="涉及的知识产权"><a href="#涉及的知识产权" class="headerlink" title="涉及的知识产权"></a>涉及的知识产权</h2><p>1.专利</p><p>FaceID 技术可能涉及到苹果公司的专利。苹果公司在 FaceID 技术中使用了结构光技术，这种技术可能拥有专利保护。如果其他公司使用类似的技术，可能会涉及到侵犯苹果公司的专利权。另外，苹果公司还可能拥有与 FaceID 技术相关的其他专利，例如用于面部识别的算法和软件。</p><p>2.商标</p><p>FaceID 是苹果公司的商标，其他公司不能随意使用 FaceID 这个名称。如果其他公司使用类似的名称来标识他们的人脸识别技术，可能会侵犯苹果公司的商标权。</p><p>3.版权</p><p>FaceID 技术涉及到的软件和算法可能受到版权保护。如果其他公司在他们的产品中使用了与 FaceID 技术类似的软件和算法，可能会涉及到版权侵犯。</p><h2 id="知识产权法律问题"><a href="#知识产权法律问题" class="headerlink" title="知识产权法律问题"></a>知识产权法律问题</h2><p>1.侵犯专利权</p><p>如果其他公司使用类似的结构光技术来开发自己的人脸识别技术，可能会侵犯苹果公司的专利权。苹果公司可以通过诉讼来维护自己的专利权，并要求其他公司停止使用类似的技术，并赔偿损失。</p><p>2.侵犯商标权</p><p>如果其他公司使用类似的名称来标识他们的人脸识别技术，可能会侵犯苹果公司的商标权。苹果公司可以通过诉讼来维护自己的商标权，并要求其他公司停止使用类似的名称，并赔偿损失。</p><p>3.侵犯版权</p><p>如果其他公司在他们的产品中使用了与 FaceID 技术类似的软件和算法，可能会涉及到版权侵犯。苹果公司可以通过诉讼来维护自己的版权，并要求其他公司停止使用类似的软件和算法，并赔偿损失。</p><h2 id="法律责任"><a href="#法律责任" class="headerlink" title="法律责任"></a>法律责任</h2><p>1.赔偿损失</p><p>如果其他公司侵犯了苹果公司的知识产权，他们需要对苹果公司造成的损失进行赔偿。赔偿金额可能包括苹果公司因此遭受的直接经济损失、间接经济损失、名誉损失等。赔偿金额的计算方法可能因案件而异，通常会考虑侵权行为的性质、侵权方的过错程度、赔偿方的经济能力等因素。</p><p>2.停止侵权行为</p><p>如果其他公司侵犯了苹果公司的知识产权，他们需要停止侵权行为。具体来说，他们可能需要停止使用与 FaceID 技术类似的结构光技术、商标和软件算法等，以避免进一步的侵权行为。</p><p>3.其他法律后果</p><p>如果其他公司侵犯了苹果公司的知识产权，他们可能还需要承担其他法律后果。例如，他们可能需要承担民事、行政或刑事责任，视具体情况而定。</p><h2 id="案例分析-2"><a href="#案例分析-2" class="headerlink" title="案例分析"></a>案例分析</h2><p>1. 苹果公司被指控侵犯了一家名为 Secure Cam 的公司的专利，该专利涉及使用红外摄像头进行面部识别的技术1。Secure Cam 要求苹果停止销售 iPhone X，并赔偿损失和律师费。苹果公司否认了侵权指控，并表示 Secure Cam 的专利是无效的，因为它没有披露任何新颖或有创造性的内容2。这个案例的分析是，苹果公司可能会以先发明或先使用的原则来反驳 Secure Cam 的主张，或者试图证明 Secure Cam 的专利不符合专利法的要求，例如明显性或非显而易见性。</p><p>2. 苹果公司被指控侵犯了一家名为 LBT IP 的公司的专利，该专利涉及使用面部识别技术来解锁移动设备的技术3。LBT IP 要求苹果停止销售 iPhone 和 iPad，并赔偿损失和律师费。苹果公司尚未对此作出回应。这个案例的分析是，苹果公司可能会以自己的 Face ID 技术与 LBT IP 的专利技术有本质区别来辩护，或者试图证明 LBT IP 的专利不具有有效性或可执行性。</p><p>3. 苹果公司被指控侵犯了一家名为 Dot Projection 的公司的专利，该专利涉及使用点阵投影器来生成面部图像的技术。Dot Projection 要求苹果停止销售 iPhone X，并赔偿损失和律师费。苹果公司尚未对此作出回应。这个案例的分析是，苹果公司可能会以自己的原深感摄像头系统与 Dot Projection 的专利技术有显著差异来辩护，或者试图证明 Dot Projection 的专利不具有创新性或实用性。</p><h1 id="FaceID技术的可持续性"><a href="#FaceID技术的可持续性" class="headerlink" title="FaceID技术的可持续性"></a>FaceID技术的可持续性</h1><p>随着人脸识别技术在各个领域的广泛应用，苹果的FaceID技术因其高安全性和便利性而受到广泛关注和讨论。然而，作为一个复杂的工程问题，FaceID技术的可持续性需要从技术、环境、经济和社会等多个方面进行深入分析和评估。接下来我将从多个角度对苹果FaceID技术的可持续性进行全面分析。</p><h2 id="可持续性分析"><a href="#可持续性分析" class="headerlink" title="可持续性分析"></a>可持续性分析</h2><ol><li>技术方面</li></ol><p>FaceID技术基于3D结构光技术，使用红外线光投射一种图案到用户的面部，然后测量该图案的扭曲来创建面部的三维模型。与传统的2D图像识别技术相比，3D结构光技术更为安全和准确，因为它可以识别面部的特定特征，如深度和轮廓，这些特征很难被仿造或复制。此外，FaceID还具有自适应学习和更新功能，可以根据用户面部特征的变化进行调整和更新，保证持续的识别准确率和安全性。</p><p>此外，苹果还实施了严格的措施来保护用户面部信息的隐私。面部信息仅存储在用户设备上，并受到安全信封的加密和保护。面部信息不会与苹果或任何第三方应用程序共享，从而确保用户完全掌控其个人数据。</p><p>总体而言，从技术角度来看，FaceID技术具有高可持续性。其3D结构光技术具有高度的安全性和准确性，其自适应学习和更新功能保证了持续的准确性和安全性。此外，其隐私保护措施确保用户完全掌控其个人数据。</p><ol><li>环境方面</li></ol><p>从环境角度来看，FaceID技术的生产和使用对环境影响相对较小。苹果一直致力于环保，采用可再生能源和可持续材料生产其产品，减少碳排放和资源浪费。此外，使用FaceID技术可以减少纸质文件和卡片的使用，减少资源消耗和环境污染。</p><p>然而，仍存在一些潜在的环境问题需要解决。例如，FaceID技术的生产需要稀土金属，这些金属通常在环境敏感区域开采，如果管理不当可能会造成环境损害。此外，由于FaceID是移动设备的一个功能，生产和处理这些设备也可能对环境产生影响。因此，苹果需要继续改善其供应链的可持续性，减少产品对环境的影响。</p><ol><li>经济方面</li></ol><p>从经济角度来看，FaceID技术对商业模式和产业链具有积极的影响。随着FaceID技术的广泛采用，越来越多的企业和组织将其用于身份验证和安全，促进了相关产业链的发展。此外，FaceID技术的应用可以降低企业成本，提高效率，增强企业的竞争力和可持续性。</p><p>然而，仍存在一些潜在的经济问题需要关注。例如，FaceID技术可能会增加移动设备的成本，这可能会限制某些用户的购买力和可访问性。此外，随着FaceID技术的越来越广泛应用，可能会出现对就业的影响，因为一些工作可能会自动化或变得多余。因此，苹果需要平衡FaceID技术的经济效益与其对可负担性、可访问性和就业的潜在影响。</p><ol><li>社会方面</li></ol><p>从社会角度来看，FaceID技术对社会安全和个人隐私保护具有积极影响。FaceID使用高度安全的人脸识别技术，可以有效地防止身份欺诈和信息泄露，确保社会安全和稳定。此外，FaceID还注重个人隐私保护，不会收集用户的面部信息或其他私人数据，保护用户的个人隐私权。</p><p>然而，仍存在一些潜在的社会问题需要关注。例如，人脸识别技术可能存在偏见和歧视，对某些种族或民族造成不公平的影响。此外，FaceID技术的广泛采用可能会引发关于隐私和数据安全的争议和担忧。因此，苹果需要继续关注社会反馈和舆情，改进其技术和政策，确保FaceID技术对社会的可持续性和公正性。</p><p>图8.iPone12与iPhone13刘海屏对比</p><h2 id="可持续性的考虑"><a href="#可持续性的考虑" class="headerlink" title="可持续性的考虑"></a>可持续性的考虑</h2><p>1. 能源效率：FaceID技术需要使用TrueDepth摄像头来扫描面部特征，这会消耗设备的电量。但相比传统的指纹识别技术，FaceID技术的功耗更低，因为TrueDepth摄像头只有在需要时才会启动，而且扫描速度很快，所以不会对设备的电池寿命产生太大影响。</p><p>2. 可靠性：FaceID技术的可靠性是一个重要的考虑因素。如果FaceID无法准确识别用户的面部特征，可能会导致用户无法解锁设备或进行身份验证。因此，FaceID技术需要经过严格的测试和验证，确保在不同的光照、角度和环境条件下都能够准确识别用户的面部特征。</p><p>3. 隐私保护：FaceID技术涉及到用户的面部特征信息，因此需要保护用户的隐私。苹果公司采用了一些措施来保护用户的隐私，例如将FaceID数据存储在设备本地而不是云端，采用了安全芯片来加密FaceID数据等。</p><p>4. 可持续性更新：FaceID技术需要不断更新来提高准确性和安全性，因此苹果公司需要不断推出更新来改进FaceID技术。这些更新需要保证向后兼容性，以确保老设备也能够获得更新。</p><h1 id="模拟推演FaceID技术的决策与管理的过程"><a href="#模拟推演FaceID技术的决策与管理的过程" class="headerlink" title="模拟推演FaceID技术的决策与管理的过程"></a>模拟推演FaceID技术的决策与管理的过程</h1><h2 id="推演前的考虑"><a href="#推演前的考虑" class="headerlink" title="推演前的考虑"></a>推演前的考虑</h2><p>为了模拟推演FaceID技术的决策与管理的过程，我们需要考虑以下几个方面：</p><ol><li>技术开发：</li></ol><blockquote><p>人脸识别算法的精度和速度，以及对不同人种、年龄、性别、姿态等情况的适应性；</p><p>系统的安全性和稳定性，避免被黑客攻击或者出现系统故障等问题；</p><p>持续的测试和优化，确保技术的可靠性和优秀的用户体验。</p></blockquote><ol><li>营销推广：</li></ol><blockquote><p>不同市场和用户群体的需求和习惯；</p><p>各种推广渠道的效果和成本；</p><p>竞争对手的策略和市场占有率。</p></blockquote><ol><li>用户反馈：</li></ol><blockquote><p>用户遇到的问题和建议，以及对用户需求的分析；</p><p>问题解决的速度和效果；</p><p>用户对技术和服务的满意度和忠诚度。</p></blockquote><ol><li>数据管理：</li></ol><blockquote><p>数据的收集、存储和使用规则；</p><p>数据的保密性和完整性；</p><p>遵守相关的法律法规，对用户的隐私和数据安全进行保护。</p></blockquote><ol><li>法律合规：</li></ol><blockquote><p>相关的法律法规和行业标准；</p><p>技术开发、数据管理和用户隐私等方面的合法性和合规性；</p><p>与法律专家进行沟通和咨询，确保技术的合法性和合规性。</p></blockquote><ol><li>团队管理：</li></ol><blockquote><p>团队成员之间的协作和沟通；</p><p>团队整体的工作效率和质量；</p><p>团队成员的培训和激励，提高团队成员的技能和积极性。</p></blockquote><ol><li>持续创新：</li></ol><blockquote><p>技术创新和产品创新，以满足不断变化的市场需求；</p><p>市场调研和用户调研，了解用户需求和市场趋势；</p><p>调整产品策略和技术方向，以保持竞争优势和创新能力。</p></blockquote><p>每个方面都包含多个因素和变化，需要综合考虑和平衡，以确保FaceID技术的持续发展和用户的满意度。</p><p>图9. Apple Park</p><h2 id="模拟推演FaceID技术的决策与管理的步骤"><a href="#模拟推演FaceID技术的决策与管理的步骤" class="headerlink" title="模拟推演FaceID技术的决策与管理的步骤"></a>模拟推演FaceID技术的决策与管理的步骤</h2><p>1. 确定技术开发团队，并制定开发计划：</p><p>在确定技术开发团队时，需要考虑团队成员的技术能力和经验，以及团队之间的协作和沟通能力。可以通过面试、技能测试等方式进行筛选和评估。在制定开发计划时，需要考虑技术开发的时间、资源和进度等因素，确保技术开发能够按时、按质量进行。</p><ol><li>建立营销推广团队，并制定推广策略：</li></ol><p>在建立营销推广团队时，需要考虑团队成员的市场推广能力和经验，以及团队之间的协作和沟通能力。可以通过面试、经验评估等方式进行筛选和评估。在制定推广策略时，需要考虑不同市场和用户群体的需求和特点，选择合适的推广渠道和方式。可以通过调研、数据分析等方式进行市场分析和用户分析，以便更好地了解用户需求和市场变化。</p><ol><li>设立用户反馈机制，并建立问题解决流程：</li></ol><p>在设立用户反馈机制时，需要考虑用户提出问题的渠道和方式，以及反馈的信息如何收集、处理和回应。可以通过建立客服团队、在线反馈渠道等方式，让用户可以方便地提出问题和建议。在建立问题解决流程时，需要考虑问题的分类、优先级和解决时间等因素。可以通过建立问题反馈和解决的流程，确保问题能够及时得到处理和解决。</p><ol><li>设立数据管理系统，并建立数据安全和隐私保护制度：</li></ol><p>在设立数据管理系统时，需要考虑数据的收集、存储、处理和使用等方面。可以建立数据管理团队，负责数据管理系统的建设和维护。在建立数据安全和隐私保护制度时，需要考虑数据的安全性、保密性和合规性等因素。可以通过制定数据安全和隐私保护制度、加密和备份等措施，确保数据的安全和保护。</p><ol><li>设立合规团队，并建立合规制度和流程：</li></ol><p>在设立合规团队时，需要考虑合规团队的职责和成员的专业能力。可以通过招聘、培训等方式建立合规团队。在建立合规制度和流程时，需要考虑相关的法律法规和政策，以及技术开发、数据管理和用户隐私等方面的合规要求。可以通过与法律专家沟通和咨询，制定合规制度和流程。</p><ol><li>定期对技术开发、营销推广、用户反馈、数据管理和合规等方面进行评估和调整：</li></ol><p>在定期对技术开发、营销推广、用户反馈、数据管理和合规等方面进行评估和调整时，需要考虑市场变化、用户需求和技术发展等因素。可以通过数据分析、用户反馈和市场调研等方式，了解用户需求和市场变化，以便及时进行调整和优化。</p><ol><li>与其他技术和应用的集成方面：</li></ol><p>考虑将FaceID技术与其他技术和应用进行集成，以便更好地满足用户需求。例如，可以将FaceID技术与支付系统、门禁系统等应用进行集成，提高系统的安全性和便利性。</p><ol><li>团队管理方面：</li></ol><p>建立一个高效的团队管理机制，确保团队成员之间的协作和沟通，以及团队整体的工作效率。同时，还需要对团队成员进行培训和激励，提高团队成员的技能</p><p>每个方面都包含多个因素和变化，需要综合考虑和平衡，以确保FaceID技术的持续发展和用户的满意度。</p>]]></content>
      
      
      <categories>
          
          <category> 读书 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 读书 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>闲着没事对比ChatGPT-3.5和ChatGPT-4编写的小说开头</title>
      <link href="/post/110aabbd.html"/>
      <url>/post/110aabbd.html</url>
      
        <content type="html"><![CDATA[<h3 id="问题：请你帮我写一个武侠小说的开头"><a href="#问题：请你帮我写一个武侠小说的开头" class="headerlink" title="问题：请你帮我写一个武侠小说的开头"></a>问题：请你帮我写一个武侠小说的开头</h3><h3 id="ChatGPT-3-5"><a href="#ChatGPT-3-5" class="headerlink" title="ChatGPT-3.5"></a>ChatGPT-3.5</h3><p>在一个风雨交加的夜晚，江湖上流传着一个传说。传说中有一个神秘的武功，只要练成了它，便可成为武林中的顶级高手，无人可敌。但是这个武功的绝学却被藏在了一个地方，只有能够通过几道考验的人才有机会学习到这门神功。</p><p>在这个夜晚，一个身穿黑色长袍的年轻人，手持一把宝剑，来到了传说中藏有这门武功的地方。在他面前，是一道巨大的瀑布，瀑布后面隐藏着那个传说中的秘密。</p><p>年轻人深吸一口气，决定开始他的考验，他跃起身形，飞跃向瀑布，同时挥剑斩向瀑布，希望能够通过这道考验，学会那门传说中的绝学。</p><p>这个年轻人会不会通过考验，学会那门传说中的绝学呢？江湖中，又会发生哪些事情呢？</p><h3 id="ChatGPT-4"><a href="#ChatGPT-4" class="headerlink" title="ChatGPT-4"></a>ChatGPT-4</h3><p>天风大陆，一个充满神秘和传奇的世界。在这片广袤的土地上，强者如林，无数英雄豪杰为了荣誉、权力、爱情、正义斗得不亦乐乎。江湖中，一个刀光剑影的故事正在悄然展开。</p><p>熊熊烈火映红了半边天，烟雾弥漫，一座寂静的山谷被火光照得如同白昼。火焰肆虐，无情地吞噬着一座座古老的宅院。在这片火海之中，一个身影如同幽灵般穿梭，脚下矫健如风，身影犹如流云，轻轻松松地避过了火焰的攻击。他的目光犀利，如同利刃般透射出强烈的戾气。</p><p>这个人名叫夜无痕，他是江湖中一个小有名气的侠客。此时此刻，他正全力闯入这场浩劫之中，寻找一件关乎天下的秘宝——玄天神石。</p><p>风吹过山谷，夜无痕矫健的身影犹如一阵疾风般穿过火海，最终来到一座古老的祠堂前。祠堂的门口，熊熊火焰仿佛遇到了什么奇异的阻力，没有涌入其中，让祠堂相对安全。</p><p>夜无痕深吸一口气，缓缓推开祠堂门，顿时一股浓烈的古香扑面而来。祠堂内充满了历史的沉积，厚重的尘埃见证了岁月的无情。夜无痕的目光在祠堂内扫视一圈，最后停留在一个神龛内的神秘石碑上。</p><p>石碑上刻满了古老的符文，充满了神秘的气息。夜无痕眼中闪过一丝惊喜，这就是他要找的玄天神石！他伸手将玄天神石握在手中，感受着其中蕴含的无尽力量，心中暗喜。</p><p>然而，就在此时，一道冰冷的声音突然传入夜无痕的耳中：“原来你就是那个夜无痕，想不到居然敢在这大火之中寻找玄天神石，你可真是不怕死啊。”</p><p>夜无痕脸色一变，他知道这一次，恐怕绝非易事。然而，为了拯救这个江湖，他别无选择。手中紧握着玄天神石，他决定勇敢地面对即将来临的一切挑战……</p>]]></content>
      
      
      <categories>
          
          <category> 生活 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ChatGPT </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git常用命令</title>
      <link href="/post/423abe9e.html"/>
      <url>/post/423abe9e.html</url>
      
        <content type="html"><![CDATA[<h3 id="第一次初始化"><a href="#第一次初始化" class="headerlink" title="第一次初始化"></a>第一次初始化</h3><ul><li>git init<br>git add .<br>git commit -m ‘first commit’<br>git remote add origin git@github.com:帐号名/仓库名.git<br>git pull origin master<br>git push origin master # -f 强推</li><li>git clone git@github.com:git帐号名/仓库名.git</li></ul><h3 id="工作基本操作"><a href="#工作基本操作" class="headerlink" title="工作基本操作"></a>工作基本操作</h3><ul><li>git checkout master 切到主分支</li><li>git fetch origin 获取最新变更</li><li>git checkout -b dev origin/master 基于主分支创建dev分支</li><li>git add . 添加到缓存</li><li>git commit -m ‘xxx’ 提交到本地仓库</li><li>git fetch origin 获取最新变更</li></ul><h3 id="初始化仓库"><a href="#初始化仓库" class="headerlink" title="初始化仓库"></a>初始化仓库</h3><p>git init</p><h3 id="查看仓库当前状态"><a href="#查看仓库当前状态" class="headerlink" title="查看仓库当前状态"></a>查看仓库当前状态</h3><p>git status</p><h3 id="文件相关操作"><a href="#文件相关操作" class="headerlink" title="文件相关操作"></a>文件相关操作</h3><p><strong>将文件添加到仓库</strong>：</p><ul><li>git add 文件名 将工作区的某个文件添加到暂存区</li><li>git add . 将当前工作区的所有文件都加入暂存区</li><li>git add -u 添加所有被tracked文件中被修改或删除的文件信息到暂存区，不处理untracked的文件</li><li>git add -A 添加所有被tracked文件中被修改或删除的文件信息到暂存区，包括untracked的文件</li><li>git add -i 进入交互界面模式，按需添加文件到缓存区</li></ul><p><strong>将暂存区文件提交到本地仓库</strong>：</p><ul><li>git commit -m “提交说明” 将暂存区内容提交到本地仓库</li><li>git commit -a -m “提交说明” 跳过缓存区操作，直接把工作区内容提交到本地仓库</li></ul><p><strong>比较文件异同</strong></p><ul><li>git diff 工作区与暂存区的差异</li><li>git diff 分支名 工作区与某分支的差异，远程分支这样写：remotes/origin/分支名</li><li>git diff HEAD 工作区与HEAD指针指向的内容差异</li><li>git diff 提交id 文件路径 工作区某文件当前版本与历史版本的差异</li><li>git diff –stage 工作区文件与上次提交的差异(1.6 版本前用 –cached)</li><li>git diff 版本TAG 查看从某个版本后都改动内容</li><li>git diff 分支A 分支B 比较从分支A和分支B的差异(也支持比较两个TAG)</li><li>git diff 分支A…分支B 比较两分支在分开后各自的改动</li></ul><p>另外：如果只想统计哪些文件被改动，多少行被改动，可以添加 –stat 参数</p><h3 id="查看历史记录"><a href="#查看历史记录" class="headerlink" title="查看历史记录"></a>查看历史记录</h3><ul><li>git log 查看所有commit记录(SHA-A校验和，作者名称，邮箱，提交时间，提交说明)</li><li>git log -p -次数 查看最近多少次的提交记录</li><li>git log –stat 简略显示每次提交的内容更改</li><li>git log –name-only 仅显示已修改的文件清单</li><li>git log –name-status 显示新增，修改，删除的文件清单</li><li>git log –oneline 让提交记录以精简的一行输出</li><li>git log –graph –all –online 图形展示分支的合并历史</li><li>git log –author=作者 查询作者的提交记录(和grep同时使用要加一个–all–match参数)</li><li>git log –grep=过滤信息 列出提交信息中包含过滤信息的提交记录</li><li>git log -S查询内容 和–grep类似，S和查询内容间没有空格</li><li>git log fileName 查看某文件的修改记录</li></ul><h3 id="代码回滚"><a href="#代码回滚" class="headerlink" title="代码回滚"></a>代码回滚</h3><ul><li>git reset HEAD^ 恢复成上次提交的版本</li><li>git reset HEAD^^ 恢复成上上次提交的版本，就是多个^，以此类推或用~次数</li><li>git reflog</li><li>git reset –hard 版本号</li><li>–soft：只是改变HEAD指针指向，缓存区和工作区不变；</li><li>–mixed：修改HEAD指针指向，暂存区内容丢失，工作区不变；</li><li>–hard：修改HEAD指针指向，暂存区内容丢失，工作区恢复以前状态；</li></ul><h3 id="版本库相关操作"><a href="#版本库相关操作" class="headerlink" title="版本库相关操作"></a>版本库相关操作</h3><ul><li>删除版本库文件：git rm 文件名</li><li>版本库里的版本替换工作区的版本：git checkout — test.txt</li></ul><h3 id="远程仓库相关操作"><a href="#远程仓库相关操作" class="headerlink" title="远程仓库相关操作"></a>远程仓库相关操作</h3><p><strong>同步远程仓库</strong>：git push -u origin master</p><p><strong>本地仓库内容推送到远程仓库</strong>：git remote add origin git@github.com:帐号名/仓库名.git</p><p><strong>从远程仓库克隆项目到本地</strong>：git clone git@github.com:git帐号名/仓库名.git</p><p><strong>查看远程库信息</strong>：git remote</p><p><strong>拉取远程分支到本地仓库</strong>：</p><ul><li>git checkout -b 本地分支 远程分支 # 会在本地新建分支，并自动切换到该分支</li><li>git fetch origin 远程分支:本地分支 # 会在本地新建分支，但不会自动切换，还需checkout</li><li>git branch –set-upstream 本地分支 远程分支 # 建立本地分支与远程分支的链接</li></ul><p><strong>同步远程仓库更新</strong>：：git fetch origin master</p><h3 id="分支相关操作"><a href="#分支相关操作" class="headerlink" title="分支相关操作"></a>分支相关操作</h3><p><strong>创建分支</strong>：git checkout -b dev  -b表示创建并切换分支<br>上面一条命令相当于一面的二条：<br>git branch dev  创建分支<br>git checkout dev  切换分支</p><p><strong>查看分支</strong>：git branch</p><p><strong>合并分支</strong>：</p><ul><li>git merge dev #用于合并指定分支到当前分支</li><li>git merge –no-ff -m “merge with no-ff” dev #加上–no-ff参数就可以用普通模式合并，合并后的历史有分支，能看出来曾经做过合并</li></ul><p><strong>删除分支</strong>：git branch -d dev</p><p><strong>查看分支合并图</strong>：git log –graph –pretty=oneline –abbrev-commit</p><h3 id="git相关配置"><a href="#git相关配置" class="headerlink" title="git相关配置"></a>git相关配置</h3><p>安装完Git后第一件要做的事，设置用户信息(global可换成local在单独项目生效)：</p><ul><li>git config –global user.name “用户名” # 设置用户名</li><li>git config –global user.email “用户邮箱” #设置邮箱</li><li>git config –global user.name # 查看用户名是否配置成功</li><li>git config –global user.email # 查看邮箱是否配置</li></ul><h3 id="其他查看配置相关"><a href="#其他查看配置相关" class="headerlink" title="其他查看配置相关"></a>其他查看配置相关</h3><ul><li>git config –global –list # 查看全局设置相关参数列表</li><li>git config –local –list # 查看本地设置相关参数列表</li><li>git config –system –list # 查看系统配置参数列表</li><li>git config –list # 查看所有Git的配置(全局+本地+系统)</li><li>git config –global color.ui true //显示git相关颜色</li></ul><h3 id="撤消某次提交"><a href="#撤消某次提交" class="headerlink" title="撤消某次提交"></a>撤消某次提交</h3><ul><li>git revert HEAD # 撤销最近的一个提交</li><li>git revert 版本号 # 撤销某次commit</li></ul><h3 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h3><ul><li>git tag 标签 //打标签命令，默认为HEAD</li><li>git tag //显示所有标签</li><li>git tag 标签 版本号 //给某个commit版本添加标签</li><li>git show 标签 //显示某个标签的详细信息</li></ul>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux常用命令</title>
      <link href="/post/d0edc1ed.html"/>
      <url>/post/d0edc1ed.html</url>
      
        <content type="html"><![CDATA[<h2 id="文件管理"><a href="#文件管理" class="headerlink" title="文件管理"></a>文件管理</h2><h3 id="目录操作"><a href="#目录操作" class="headerlink" title="目录操作"></a>目录操作</h3><p>切换目录 <code>cd</code></p><p>查看目录 <code>ls</code></p><ul><li><code>-l</code>  列出文件详细信息 或者直接<code>ll</code></li><li><code>-a</code>  列出当前目录下所有文件及目录，包括隐藏的a(all)</li></ul><p>创建目录 <code>mkdir</code></p><ul><li>-p    创建目录，若无父目录，则创建p(parent)</li></ul><p>输出信息 <code>echo</code></p><p>打印文件到命令行(查看文件) <code>cat</code></p><p>改变文件所属用户 <code>chown</code></p><p>改变文件所属组 <code>chgrp</code></p><p>下载文件 <code>wget</code></p><p>在文本文件中查找某个字符串 <code>grep</code></p><p>统计文本中行数、字数、字符数 <code>wc</code></p><p>部分显示 <code>more/less</code></p><p>查找文件 <code>find / -name &#39;auto.cnf&#39;</code></p><p>创建空文件 <code>touch</code></p><p>复制文件 <code>cp</code></p><p>移动或重命名 <code>mv</code></p><p>删除文件 <code>rm</code></p><ul><li>-r   递归删除，可删除子目录及文件</li><li>-f   强制删除</li></ul><p>删除空目录 <code>rmdir</code></p><p>树形结构显示目录，需要安装tree包  <code>tree</code></p><p>显示当前目录 <code>pwd</code></p><p>创建链接文件 <code>ln</code></p><p>分页显示文本文件内容 <code>more、less</code></p><p>显示文件头、尾内容  <code>head、tail</code></p><h3 id="vim操作"><a href="#vim操作" class="headerlink" title="vim操作"></a>vim操作</h3><p>进入编辑器 <code>vi/vim</code>，vim三种模式：命令模式、插入模式、编辑模式。使用ESC或i或：来切换模式。</p><ul><li>进入编辑模式插入 <code>i</code></li><li>退出编辑模式 <code>esc</code></li><li>保存:后面输入<code>w</code></li><li>退出:后面输入<code>q</code></li><li>不保存退出:后面输入<code>q!</code></li><li>显示行号 <code>set number</code></li><li>查找关键字 <code>/xxxx</code> 按n跳到下一个，shift+n上一个</li><li>复制光标所在行，并粘贴 <code>yyp</code></li><li>h(左移一个字符←)、j(下一行↓)、k(上一行↑)、l(右移一个字符→)</li></ul><h3 id="打包压缩相关命令"><a href="#打包压缩相关命令" class="headerlink" title="打包压缩相关命令"></a>打包压缩相关命令</h3><p>打包压缩 <code>tar\gzip\bzip2</code></p><ul><li><code>-c</code>归档文件</li><li><code>-x</code> 压缩文件</li><li><code>-z</code> gzip压缩文件</li><li><code>-j</code> bzip2压缩文件</li><li><code>-v</code> 显示压缩或解压缩过程 v(view)</li><li><code>-f</code> 使用档名</li></ul><p>例：</p><p>只打包，不压缩:<code>tar -cvf /home/abc.tar /home/abc</code></p><p>打包，并用gzip压缩:<code>tar -zcvf /home/abc.tar.gz /home/abc</code></p><p>打包，并用bzip2压缩:<code>tar -jcvf /home/abc.tar.bz2 /home/abc</code></p><p>如果想解压缩，就直接替换上面的命令<code>tar -cvf / tar -zcvf / tar -jcvf</code> 中的“c” 换成“x” 就可以了。</p><h3 id="Linux管道"><a href="#Linux管道" class="headerlink" title="Linux管道"></a>Linux管道</h3><p>将一个命令的标准输出作为另一个命令的标准输入。也就是把几个命令组合起来使用，后一个命令除以前一个命令的结果。</p><p>例：grep -r “close” /home/* | more   在home目录下所有文件中查找，包括close的文件，并分页输出。</p><h2 id="文件权限管理"><a href="#文件权限管理" class="headerlink" title="文件权限管理"></a>文件权限管理</h2><h3 id="三种基本权限"><a href="#三种基本权限" class="headerlink" title="三种基本权限"></a>三种基本权限</h3><p>R：读，数值表示为 4</p><p>W：写，数值表示为 2</p><p>X：可执行，数值表示为1</p><h3 id="更改权限"><a href="#更改权限" class="headerlink" title="更改权限"></a>更改权限</h3><p>更改权限：<code>sudo chmod</code> [u所属用户  g所属组  o其他用户  a所有用户]  [+增加权限  -减少权限]  [r  w  x]  目录名</p><p>例如：有一个文件 filename，权限为<code>-rw-r----x</code> ,将权限值改为<code>-rwxrw-r-x</code>，用数值表示为765</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo chmod u+x g+w o+r filename` 也可以用数值表示 `sudo chmod 765 filename</span><br></pre></td></tr></table></figure><h2 id="运行程序"><a href="#运行程序" class="headerlink" title="运行程序"></a>运行程序</h2><h3 id="命令行运行"><a href="#命令行运行" class="headerlink" title="命令行运行"></a>命令行运行</h3><p>运行<code>./filename</code></p><p>退出<code>ctrl+c</code></p><h3 id="后台运行"><a href="#后台运行" class="headerlink" title="后台运行"></a>后台运行</h3><p>运行 <code>nohup command &gt;out.file 2&gt;&amp;1 &amp;</code></p><p>退出 <code>ps -ef |grep 关键字 |awk &#39;&#123;print $2&#125;&#39;|xarg kill -9</code></p><h3 id="服务方式运行"><a href="#服务方式运行" class="headerlink" title="服务方式运行"></a>服务方式运行</h3><p>设置开机启动 <code>systemctl enable</code></p><p>启动<code>systemctl start</code></p><p>关闭<code>systemctl stop</code></p><h2 id="系统相关"><a href="#系统相关" class="headerlink" title="系统相关"></a>系统相关</h2><h3 id="系统管理命令"><a href="#系统管理命令" class="headerlink" title="系统管理命令"></a>系统管理命令</h3><p>显示指定文件的详细信息，比ls更详细 <code>stat</code></p><p>显示在线登陆用户 <code>who</code></p><p>显示当前操作用户<code>whoami</code></p><p>显示主机名<code>hostname</code></p><p>显示系统信息<code>uname</code></p><p>动态显示当前耗费资源最多进程信息<code>top</code></p><p>显示瞬间进程状态  <code>ps \ ps -aux</code></p><p>查看目录大小 <code>du -h /home</code> (带有单位显示目录信息)</p><p>查看磁盘大小 <code>df -h</code> (带有单位显示磁盘信息)</p><p>查看网络情况 <code>ifconfig</code></p><p>测试网络连通 <code>ping</code></p><p>显示网络状态信息 <code>netstat</code></p><p>命令不会用了，看文档 如：<code>man grep</code></p><p>清屏 <code>clear</code></p><p>对命令重命名 <code>alias</code> ，如：<code>alias showmeit=&quot;ps -aux&quot;</code> ，解除使用<code>unaliax showmeit</code></p><p>杀死进程 <code>kill</code>，可以先用<code>ps</code> 或 <code>top</code>命令查看进程的id，然后再用kill命令杀死进程。<code>kill -9</code> 强制删除</p><h3 id="防火墙"><a href="#防火墙" class="headerlink" title="防火墙"></a>防火墙</h3><p>查看防火墙状态 <code>firewall-cmd --state</code></p><p>停止防火墙 <code>systemctl stop firewalld.service</code></p><p>禁止firewall开机启动 <code>systemctl disable firewalld.service</code></p><h3 id="关机和重启"><a href="#关机和重启" class="headerlink" title="关机和重启"></a>关机和重启</h3><p>关机 <code>shutdown -h now</code></p><ul><li>-r 关机重启</li><li>-h 关机不重启</li><li>now 立刻关机</li></ul><p>重启 <code>reboot</code></p><p>关机  <code>halt</code></p><h3 id="网络配置"><a href="#网络配置" class="headerlink" title="网络配置"></a>网络配置</h3><p>查看网卡信息 <code>ifconfig</code></p><p>网络配置 <code>/etc/sysconfig/network-script/ifcfg-eth0</code></p><p>配置网卡 <code>/etc/udev/rules.d/70-persistent-net.rules</code></p><h2 id="用户管理"><a href="#用户管理" class="headerlink" title="用户管理"></a>用户管理</h2><p>创建用户 <code>useradd</code></p><p>设置密码 <code>passwd</code></p><ul><li>存储组账号 <code>/etc/group</code></li><li>系统用户配置文件<code>/etc/passwd</code></li></ul><p>存储用户账号的密码 <code>/etc/shadow</code></p><p>存储用户组账号的密码<code>/etc/gshadow</code></p><p>用户名<code>useradd</code></p><p>用户名<code>userdel</code></p><p>用户名<code>adduser</code></p><p>组名<code>groupadd</code></p><p>组名<code>groupdel</code></p><p>给root设置密码<code>passwd root</code></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">su root</span><br><span class="line">su - root</span><br></pre></td></tr></table></figure><p>系统环境变量<code>/etc/profile</code></p><p>用户环境变量<code>bash_profile</code></p><p>用户环境变量<code>.bashrc</code></p><p><code>su user</code> 切换用户，加载配置文件.bashrc</p><p><code>su - user</code> 切换用户，加载配置文件/etc/profile ，加载bash_profile</p><h2 id="安装软件"><a href="#安装软件" class="headerlink" title="安装软件"></a>安装软件</h2><h3 id="下载rpm安装包方式"><a href="#下载rpm安装包方式" class="headerlink" title="下载rpm安装包方式"></a>下载rpm安装包方式</h3><p>安装 <code>rpm -i jdk-XXX_linux-x64_bin.rpm</code></p><p>查找 <code>rpm -qa | grep jdk</code></p><p>列表 <code>rpm -qa | more</code></p><blockquote><p>ubuntu dpkg 方式</p><p>查找dpkg -I | grep jdk</p><p>列表dpkg -I | more</p><p>安装dpkg -i jdk-XXX_linux-x64_bin.deb</p></blockquote><h3 id="yum方式"><a href="#yum方式" class="headerlink" title="yum方式"></a>yum方式</h3><p>搜索 <code>yum search jdk</code></p><p>安装 <code>yum install java-11-openjdk.x86_64</code></p><p>删除 <code>yum erase java-11 -openjdk.x86 64</code></p><p>配置文件 <code>/etc/yum.repos.d/CentOS-Base.repo</code></p><blockquote><p>ubuntu apt-get 方式</p><p>搜索 apt・cache search jdk</p><p>安装apt-get install openjdk-9-jdk</p><p>删除apt-get purge openjdk-9-jdk</p><p>配置文件/etc/apt/sources. Iist</p></blockquote><h3 id="下载压缩文件方式"><a href="#下载压缩文件方式" class="headerlink" title="下载压缩文件方式"></a>下载压缩文件方式</h3><p>编辑 .bashrc</p><p>环境变量配置</p><ul><li>打开环境变量文件 <code>vi /etc/profile</code></li><li>配置环境变量 <code>export JAVA_HOME=/root/j d k-XXX_lin ux-x64</code></li><li><code>export PATH=$JAVA HOME/bin:$PATH</code></li><li>刷新配置 <code>source /etc/profile</code></li></ul><p>最后，欢迎大家提问和交流。</p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Markdown基本语法</title>
      <link href="/post/5d36ff15.html"/>
      <url>/post/5d36ff15.html</url>
      
        <content type="html"><![CDATA[<h3 id="Markdown-基本语法"><a href="#Markdown-基本语法" class="headerlink" title="Markdown 基本语法"></a>Markdown 基本语法</h3><h4 id="标题语法"><a href="#标题语法" class="headerlink" title="标题语法"></a>标题语法</h4><p>Markdown 语法利用输入#的数量来确定标题的级别。</p><h1 id="这是一级标题"><a href="#这是一级标题" class="headerlink" title="这是一级标题"></a>这是一级标题</h1><h2 id="这是二级标题"><a href="#这是二级标题" class="headerlink" title="这是二级标题"></a>这是二级标题</h2><h3 id="这是三级标题"><a href="#这是三级标题" class="headerlink" title="这是三级标题"></a>这是三级标题</h3><h4 id="这是四级标题"><a href="#这是四级标题" class="headerlink" title="这是四级标题"></a>这是四级标题</h4><h5 id="这是五级标题"><a href="#这是五级标题" class="headerlink" title="这是五级标题"></a>这是五级标题</h5><h6 id="这是六级标题"><a href="#这是六级标题" class="headerlink" title="这是六级标题"></a>这是六级标题</h6><p>实现上述只需要在标题内容前加上#的数量和空格，这样 Markdown 语法就会把它们实现为对应的标题；当然在一些适配的编辑器里也可以使用　Ctrl　＋ 数字(1~6) 来快捷改变标题级别。</p><p>建议在 Typora 的设置中打开开启调试，这样就能在编辑界面快速查看源码和编辑源了。</p><p>笔记应用会利用级别标题来生成笔记的目录；</p><h4 id="换行语法"><a href="#换行语法" class="headerlink" title="换行语法"></a>换行语法</h4><p>在Markdown 中直接输入换行，将优先配置排版，这不是真正的换行，<strong>只需要在行末输入两个即以上的空格即可再回车即可执行真正的换行</strong>；</p><h4 id="段落语法"><a href="#段落语法" class="headerlink" title="段落语法"></a>段落语法</h4><p>要创建段落，请使用空白行将行或多行文本进行分隔。即在两个段落之间输入一个空行进行分隔，Markdown 会自动识别为段落。</p><h4 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h4><h4 id="有序列表"><a href="#有序列表" class="headerlink" title="有序列表"></a>有序列表</h4><p>要创建有序列表，请在每个列表项前添加数字并紧跟一个英文句点。数字不必按数学顺序排列，但是列表应当以数字 1 起始。</p><p>例子:</p><ol><li>第一项 使用数字加英文句点，编辑项名称后使用回车会自动创建第二项；</li><li><p>这是第二项， 回车之后，Markdown 自动为你添加序号。</p><ol><li><p>这是第二项子项一 使用换行加 tab 键即可实现</p></li><li><p>这是第二项子项二</p></li></ol></li></ol><h4 id="无序列表"><a href="#无序列表" class="headerlink" title="无序列表"></a>无序列表</h4><p>要创建无序列表，请在每个列表项前面添加破折号 (-)、星号 (*) 或加号 (+) 。缩进一个或多个列表项可创建嵌套列表。</p><p>例子：</p><ul><li>第一项</li><li>第一项子项</li><li><p>第二项</p><ol><li><p>第二项的有序子项 此处使用 换行 加 tab键 加 - 实现下一个无序子项；</p><ul><li><p>子项的无序子项</p><ul><li>子项的无序子项 此处使用 shift + tab键 ，实现第二个有序项；</li></ul></li></ul></li><li><p>第二个项的无序子项</p></li></ol></li></ul><h4 id="强调语法"><a href="#强调语法" class="headerlink" title="强调语法"></a>强调语法</h4><p>通过将文本设置为粗体或斜体来强调其重要性。</p><h4 id="粗体（Bold）"><a href="#粗体（Bold）" class="headerlink" title="粗体（Bold）"></a>粗体（Bold）</h4><p>要加粗文本，请在单词或短语的前后各添加两个星号（asterisks）或下划线（underscores）。如需加粗一个单词或短语的中间部分用以表示强调的话，请在要加粗部分的两侧各添加两个星号（asterisks）。<br><strong>这是一段粗体文本</strong></p><h4 id="斜体（Italic）"><a href="#斜体（Italic）" class="headerlink" title="斜体（Italic）"></a>斜体（Italic）</h4><p><em>这是一段斜体文本</em><br>要用斜体显示文本，请在单词或短语前后添加一个星号（asterisk）或下划线（underscore）。要斜体突出单词的中间部分，请在字母前后各添加一个星号，中间不要带空格。</p><p><strong>粗体（Bold）和斜体（Italic）</strong></p><p><strong><em>这是一段粗斜体文本</em></strong><br>要同时用粗体和斜体突出显示文本，请在单词或短语的前后各添加三个星号或下划线。要加粗并用斜体显示单词或短语的中间部分，请在要突出显示的部分前后各添加三个星号，中间不要带空格。<br>要创建块引用，请在段落前添加一个 > 符号。  </p><h4 id="引用语法"><a href="#引用语法" class="headerlink" title="引用语法"></a>引用语法</h4><p>要创建块引用，请在段落前添加一个 > 符号。</p><blockquote><p>粗体（Bold）和斜体（Italic） 使用引用之后，文本样式会发生变化</p><blockquote><p>块引用可以嵌套。在要嵌套的段落前添加一个 >> 符号。</p></blockquote></blockquote><h4 id="分隔线语法"><a href="#分隔线语法" class="headerlink" title="分隔线语法"></a>分隔线语法</h4><p>要创建分隔线，请在单独一行上使用三个或多个星号 (***)、破折号 (—-) 或下划线 (___) ，并且不能包含其他内容。</p><hr><p>以上就是一个分隔线</p><h4 id="链接语法"><a href="#链接语法" class="headerlink" title="链接语法"></a>链接语法</h4><p>链接文本放在中括号内，链接地址放在后面的括号中，链接title可选。<br>超链接Markdown语法代码：[超链接显示名](超链接地址 “超链接title”)</p><h4 id="图片语法"><a href="#图片语法" class="headerlink" title="图片语法"></a>图片语法</h4><p>要添加图像，请使用感叹号 (!), 然后在方括号增加替代文本，图片链接放在圆括号里，括号里的链接后可以增加一个可选的图片标题文本。</p><hr><p>好了，以上就是我整理的 Markdown 的基本语法，掌握以上内容，你就可以用Typora(笔记应用)为自己写一篇笔记了。程序员生涯中的博客、文档、笔记大多都是用它写的。最重要的是，掌握这些，你就能高效的写出美观的笔记了，从此，开启你的学习生涯。（大家可以联系我下载Typora）</p>]]></content>
      
      
      <categories>
          
          <category> 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Markdown </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
